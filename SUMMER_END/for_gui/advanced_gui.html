<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8" />
	<title>Enhanced Text Comparison Viewer</title>
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<style>
:root {
  --bg-color: #ffffff;
  --text-color: #000000;
  --panel-bg: #f8f8f8;
  --border-color: #cccccc;
  --accent-color: #007acc;
  --hover-bg: #f0f0f0;
  --original-bg: #f9f9f9;
  --diff-list-bg: #f9f9f9;
  --controls-bg: #f5f5f5;
  --edit-mode-bg: #fff3cd;
  --edit-mode-border: #ffeaa7;
}

.dark-mode {
  --bg-color: #1a1a1a;
  --text-color: #e0e0e0;
  --panel-bg: #2d2d2d;
  --border-color: #444444;
  --accent-color: #4dabf7;
  --hover-bg: #3d3d3d;
  --original-bg: #2a2a2a;
  --diff-list-bg: #2a2a2a;
  --controls-bg: #2d2d2d;
  --edit-mode-bg: #3d3c1a;
  --edit-mode-border: #5d5a2a;
}

body {
  margin: 1em;
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s, color 0.3s;
}

.controls {
  margin-bottom: 1em;
  background: var(--controls-bg);
  border-radius: 4px;
  padding: 8px;
  border: 1px solid var(--border-color);
}

.viewer {
  display: flex;
  height: 50vh;
  border: 1px solid var(--border-color);
  overflow: auto;
  border-radius: 4px;
  background-color: var(--panel-bg);
}

.pane-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
}

.pane-title {
  padding: 8px;
  font-weight: bold;
  text-align: center;
  border-bottom: 1px solid var(--border-color);
  background: var(--panel-bg);
}

.pane {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
}

.original-text {
  background: var(--original-bg);
  padding: 8px;
  margin-bottom: 10px;
  border-left: 3px solid var(--accent-color);
  font-style: italic;
  border-radius: 3px;
}

.original-label {
  font-size: 0.8em;
  color: var(--text-color);
  opacity: 0.7;
  font-weight: bold;
  margin-bottom: 4px;
}

.word-block {
  display: inline-block;
  margin: 4px;
  text-align: center;
  padding: 4px;
  border-radius: 3px;
  transition: background-color 0.2s;
  position: relative;
}

.word-block:hover {
  background-color: var(--hover-bg);
}

.word-block span {
  display: block;
  font-size: 0.75em;
  cursor: pointer;
}

.scansion {
  color: #888;
}

.dark-mode .scansion {
  color: #aaa;
}

.scansion.editable {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  padding: 1px 3px;
  border-radius: 2px;
  min-width: 20px;
  cursor: text;
}

.scansion.editable:hover {
  background: var(--hover-bg);
}

.tag {
  color: var(--accent-color);
  cursor: pointer;
}

.tag.no-tag {
  color: #bbb;
  font-style: italic;
  cursor: pointer;
}

.dark-mode .tag.no-tag {
  color: #888;
}

.word {
  font-weight: bold;
}

.word.editable {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  padding: 2px 4px;
  border-radius: 2px;
  cursor: text;
  min-width: 30px;
}

.word.editable:hover {
  background: var(--hover-bg);
}

.word-controls {
  display: inline-flex;
  gap: 2px;
  margin-right: 4px;
  vertical-align: middle;
}

.word-control-btn {
  background: var(--accent-color);
  color: white;
  border: none;
  font-size: 0.75em;
  padding: 2px 5px;
  border-radius: 2px;
  cursor: pointer;
  min-width: 22px;
}

.word-control-btn:hover {
  opacity: 0.9;
}

.word-control-btn.add-before {
  background: #28a745;
}

.add-word-btn {
  display: inline-block;
  background: #28a745;
  color: white;
  border: none;
  font-size: 0.8em;
  padding: 2px 6px;
  margin: 2px;
  border-radius: 3px;
  cursor: pointer;
  vertical-align: middle;
}

.add-word-btn:hover {
  opacity: 0.9;
}

.tag-editor {
  position: absolute;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  z-index: 1000;
  padding: 4px;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  min-width: 150px;
  border-radius: 4px;
}

.tag-editor div {
  padding: 2px 6px;
  cursor: pointer;
}

.tag-editor div:hover {
  background: var(--hover-bg);
}

.diff-list {
  max-width: 100%;
  overflow-x: auto;
  white-space: nowrap;
  margin-bottom: 10px;
  padding: 8px;
  border-bottom: 1px solid var(--border-color);
  background: var(--diff-list-bg);
  border-radius: 4px;
}

.line-number {
  cursor: pointer;
  margin-right: 8px;
  color: #900;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 3px;
  white-space: nowrap;
}

.dark-mode .line-number {
  color: #ff6b6b;
}

.line-number:hover {
  background: var(--hover-bg);
}

input.tag-input {
  width: 100%;
  box-sizing: border-box;
  margin-top: 6px;
  padding: 4px 6px;
  font-size: 0.9em;
  border: 1px solid var(--border-color);
  border-radius: 2px;
  background: var(--bg-color);
  color: var(--text-color);
}

.navigation, .diff-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-top: 12px;
  padding: 8px;
  background: var(--controls-bg);
  border-radius: 4px;
  border: 1px solid var(--border-color);
}

#flagBtn {
  font-size: 1.3em;
  cursor: pointer;
}


.line-display {
  font-size: 1.1em;
  font-weight: bold;
  margin: 0 10px;
  min-width: 300px;
  overflow: visible;
  white-space: normal;
  text-align: center;
}

.flag {
  cursor: pointer;
  font-size: 1.1em;
  margin-left: 4px;
  user-select: none;
  transition: transform 0.2s;
}

.flag:hover {
  transform: scale(1.2);
}

.flag.green {
  color: green;
}

.flag.red {
  color: red;
}

button {
  padding: 6px 12px;
  background: var(--hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
  color: var(--text-color);
}

button:hover {
  background: var(--panel-bg);
}

label {
  margin-right: 15px;
}

.edit-mode-controls {
  margin-top: 10px;
  padding: 8px;
  background: var(--edit-mode-bg);
  border: 1px solid var(--edit-mode-border);
  border-radius: 4px;
}

.inline-edit {
  background: var(--edit-mode-bg);
  border: 1px solid var(--border-color);
  padding: 2px 4px;
  border-radius: 2px;
  font-size: inherit;
  font-family: inherit;
  min-width: 20px;
  color: var(--text-color);
}

/* Dark mode toggle button */
.dark-mode-toggle {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  background: var(--controls-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 0.9em;
  color: var(--text-color);
}

.dark-mode-toggle:hover {
  background: var(--hover-bg);
}

input[type="text"], input[type="file"] {
  background: var(--bg-color);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  padding: 4px;
}

input[type="checkbox"] {
  margin-right: 5px;
}
	</style>
  </head>
  <body>

	<button class="dark-mode-toggle" id="darkModeToggle">ðŸŒ™ Dark Mode</button>

	<div class="controls">
	  <label>CSV File: <input type="file" id="csvFile" accept=".csv" /></label>
	  <label>Tag JSON: <input type="file" id="tagJsonFile" accept=".json" /></label>
	  <button id="export">Export CSV</button>
	  <label><input type="checkbox" id="toggleScansion" checked /> Show Scansion</label>
	  <label><input type="checkbox" id="toggleTags" checked /> Show Tags</label>
	  <label><input type="checkbox" id="toggleOriginal" checked /> Show Original Text</label>
	  <label><input type="checkbox" id="editMode" /> Edit Mode</label>
	  <label><input type="checkbox" id="useRiversideSuggestions" /> Use Riverside Tag Suggestions</label>
	  <label>
	  	<input type="checkbox" id="hideGreenFlags" />
		  Hide Green-Flagged Lines
	  </label>
	</div>

	<div class="edit-mode-controls" id="editModeControls" style="display: none;">
	  <strong>Edit Mode Active:</strong> Click green + to add word before, blue - to remove word, or click text/scansion to edit
	</div>

	<div class="navigation">
	  <button id="prevLine">Previous</button>
	  <span class="line-display" id="currentLineDisplay">Line: â€“</span>
	  <button id="nextLine">Next</button>
	</div>

	<div class="diff-controls">
	  <button id="prevDiff">Previous Difference</button>
	  <span id="flagBtn" class="flag" title="Click to toggle flag on current line">âš‘</span>
	  <button id="nextDiff">Next Difference</button>
	</div>

	<div class="diff-list" id="diffList"></div>

	<div class="viewer">
	  <div class="pane-container">
		<div class="pane-title">Riverside</div>
		<div class="pane" id="riversidePane"></div>
	  </div>
	  <div class="pane-container">
		<div class="pane-title">Oxford</div>
		<div class="pane" id="oxfordPane"></div>
	  </div>
	</div>

	<script>
	  let csvData = [];
	  let tagSuggestions = {};
	  let oxfordTagEdits = {};
	  let oxfordTextEdits = {};
	  let oxfordScansionEdits = {};
	  let currentLine = null;
	  let lineFlags = {};
	  let editMode = false;
	  let darkMode = false;
	  let initialGreenDiffs = new Set();   // diff lines green at load
	  let diffLineIds = new Set();         // all diff line IDs

	  const riversidePane = document.getElementById('riversidePane');
	  const oxfordPane = document.getElementById('oxfordPane');
	  const toggleScansion = document.getElementById('toggleScansion');
	  const toggleTags = document.getElementById('toggleTags');
	  const toggleOriginal = document.getElementById('toggleOriginal');
	  const editModeCheckbox = document.getElementById('editMode');
	  const hideGreenFlags = document.getElementById('hideGreenFlags');
	  const editModeControls = document.getElementById('editModeControls');
	  const currentLineDisplay = document.getElementById('currentLineDisplay');
	  const useRiversideSuggestions = document.getElementById('useRiversideSuggestions');
	  const darkModeToggle = document.getElementById('darkModeToggle');

	  // Dark mode toggle
	  darkModeToggle.addEventListener('click', () => {
		darkMode = !darkMode;
		if (darkMode) {
		  document.body.classList.add('dark-mode');
		  darkModeToggle.textContent = 'â˜€ï¸ Light Mode';
		} else {
		  document.body.classList.remove('dark-mode');
		  darkModeToggle.textContent = 'ðŸŒ™ Dark Mode';
		}
	  });

	  // Helper function to create a consistent line identifier
	  function getLineId(lineNumber) {
		return String(lineNumber).trim();
	  }

	  // Helper function to find row by line number (handles various formats)
	  function findRowByLineNumber(lineNumber) {
		const searchId = getLineId(lineNumber);
		return csvData.find(r => getLineId(r["LINE_NUMBER"]) === searchId);
	  }

	  // Add this function to ensure edit mode is properly enabled
	  function ensureEditMode() {
		if (editModeCheckbox.checked && !editMode) {
		  editMode = true;
		  editModeControls.style.display = 'block';
		}
	  }

	  // Also add a function to refresh edit mode state
	  function refreshEditMode() {
		editMode = editModeCheckbox.checked;
		editModeControls.style.display = editMode ? 'block' : 'none';
		if (currentLine) {
		  displayLine(currentLine);
		}
	  }

	  editModeCheckbox.addEventListener('change', (e) => {
		editMode = e.target.checked;
		editModeControls.style.display = editMode ? 'block' : 'none';
		// Force refresh of the current line to update editability
		if (currentLine) {
		  displayLine(currentLine);
		}
	  });
	  
	  hideGreenFlags.addEventListener('change', () => {
		showDiffList();
	  });

	  document.getElementById('csvFile').addEventListener('change', (e) => {
		const file = e.target.files[0];
		Papa.parse(file, {
		  header: true,
		  skipEmptyLines: true,
		  complete: function(results) {
			csvData = results.data;
			initialGreenDiffs.clear();
			diffLineIds.clear();

			for (const row of csvData) {
			  const lineId = getLineId(row["LINE_NUMBER"]);
			  const color = (row["FLAG_COLOR"] || "").toLowerCase();

			  if (row["MATCH"] === "DIFF") {
				diffLineIds.add(lineId);

				if (color === "green") {
				  initialGreenDiffs.add(lineId);
				  lineFlags[lineId] = "green";
				} else if (color === "red") {
				  lineFlags[lineId] = "red";
				}
			  }
			}

			lineFlags = {};
			oxfordTagEdits = {};
			oxfordTextEdits = {};
			oxfordScansionEdits = {};
			
			for (const row of csvData) {
			  const lineId = getLineId(row["LINE_NUMBER"]);
			  const color = (row["FLAG_COLOR"] || "").toLowerCase();
			  if (color === "green" || color === "red") {
				lineFlags[lineId] = color;
			  }
			}
			
			// Ensure edit mode is properly enabled
			ensureEditMode();
			
			showDiffList();
			if (csvData.length > 0) {
			  displayLine(csvData[0]["LINE_NUMBER"]);
			}
		  }
		});
	  });

	  document.getElementById('tagJsonFile').addEventListener('change', (e) => {
		const reader = new FileReader();
		reader.onload = () => {
		  try {
			tagSuggestions = JSON.parse(reader.result);
		  } catch (err) {
			alert('Error parsing JSON tag suggestions: ' + err.message);
			tagSuggestions = {};
		  }
		};
		reader.readAsText(e.target.files[0]);
	  });

	  document.getElementById('export').addEventListener('click', () => {
		const updatedCSV = csvData.map(row => {
		  const lineId = getLineId(row["LINE_NUMBER"]);
		  if (oxfordTagEdits[lineId]) {
			row["OXFORD_TAGGING"] = oxfordTagEdits[lineId].join(" ");
		  }
		  if (oxfordTextEdits[lineId]) {
			row["OXFORD_TEXT"] = oxfordTextEdits[lineId].join(" ");
		  }
		  if (oxfordScansionEdits[lineId]) {
			row["OXFORD_SCANSION"] = oxfordScansionEdits[lineId].join(" ");
		  }
		  row["FLAG_COLOR"] = lineFlags[lineId] || "";
		  return row;
		});

		const csv = Papa.unparse(updatedCSV);
		const blob = new Blob([csv], {type: 'text/csv'});
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = 'updated_output.csv';
		a.click();
		URL.revokeObjectURL(url);
	  });

	  toggleScansion.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleTags.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleOriginal.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });

	  document.getElementById('prevLine').addEventListener('click', () => {
		navigateLine(-1);
	  });
	  document.getElementById('nextLine').addEventListener('click', () => {
		navigateLine(1);
	  });
	  document.getElementById('prevDiff').addEventListener('click', () => {
		navigateDiff(-1);
	  });
	  document.getElementById('nextDiff').addEventListener('click', () => {
		navigateDiff(1);
	  });
	  
	  const flagBtn = document.getElementById("flagBtn");
	  flagBtn.style.fontSize = "1.4em";
	  flagBtn.style.cursor = "pointer";
	  flagBtn.style.marginLeft = "10px";

	  flagBtn.onclick = () => {
		toggleFlag(currentLine);
		const lineId = getLineId(currentLine);
		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
		showDiffList();
	  };

	function showDiffList() {
	  const container = document.getElementById('diffList');
	  container.innerHTML = "";

	  // ---- Progress header ----
	  const progress = document.createElement("div");
	  progress.id = "progressDisplay";
	  progress.style.fontWeight = "bold";
	  progress.style.marginBottom = "6px";
	  progress.style.display = "flex";
	  progress.style.justifyContent = "center";
	  progress.style.textAlign = "center";

	  container.appendChild(progress);

	  // ---- Diff line list ----
	  const label = document.createElement("div");
	  label.textContent = "Lines with differences:";
	  label.style.display = "inline-block";
	  label.style.marginRight = "8px";
	  container.appendChild(label);

	  csvData.forEach(row => {
		if (row["MATCH"] !== "DIFF") return;

		const lineNum = row["LINE_NUMBER"];
		const lineId = getLineId(lineNum);
		const flag = lineFlags[lineId];

		// Skip green-flagged lines if toggle is on
		if (hideGreenFlags.checked && flag === "green") return;

		const flagEl = document.createElement("span");
		flagEl.className = "flag";
		flagEl.textContent = getFlagSymbol(flag);
		if (flag) flagEl.classList.add(flag);
		flagEl.onclick = (e) => {
		  e.stopPropagation();
		  toggleFlag(lineNum);
		  showDiffList(); // refresh + progress update
		};

		const span = document.createElement("span");
		span.className = "line-number";
		span.textContent = lineNum;
		span.onclick = () => displayLine(lineNum);

		container.appendChild(flagEl);
		container.appendChild(span);
	  });

	  updateProgressDisplay();
	}

	function updateProgressDisplay() {
	  const progressEl = document.getElementById("progressDisplay");
	  if (!progressEl || diffLineIds.size === 0) return;

	  const diffIds = Array.from(diffLineIds);

	  // TOTAL progress
	  const totalGreen = diffIds.filter(
		id => lineFlags[id] === "green"
	  ).length;
	  const totalPct = ((totalGreen / diffIds.length) * 100).toFixed(1);

	  // SESSION progress
	  const sessionDenominator = diffIds.filter(
		id => !initialGreenDiffs.has(id)
	  ).length;

	  const sessionNumerator = diffIds.filter(
		id =>
		  !initialGreenDiffs.has(id) &&
		  lineFlags[id] === "green"
	  ).length;

	  const sessionPct = sessionDenominator > 0
		? ((sessionNumerator / sessionDenominator) * 100).toFixed(1)
		: "100.0";

	  progressEl.textContent =
		`Session: ${sessionNumerator}/${sessionDenominator} (${sessionPct}%) | ` +
		`Total: ${totalGreen}/${diffIds.length} (${totalPct}%)`;
	}

	  function getFlagSymbol(state) {
		if (state === "green") return "âœ…";
		if (state === "red") return "ðŸš©";
		return "âš";
	  }

	  function toggleFlag(lineNum) {
		const lineId = getLineId(lineNum);
		const current = lineFlags[lineId];
		if (!current) lineFlags[lineId] = "green";
		else if (current === "green") lineFlags[lineId] = "red";
		else delete lineFlags[lineId];
	  }

	  function displayLine(lineNum) {
		currentLine = lineNum;
		currentLineDisplay.textContent = `Line: ${currentLine}`;
		currentLineDisplay.title = currentLine;
		
		const row = findRowByLineNumber(lineNum);
		if (!row) return;

		const lineId = getLineId(lineNum);

		const rText = (row["RIVERSIDE_TEXT"] || "").split(" ").filter(w => w.trim());
		const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ");
		let oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		while (oTags.length < oText.length) oTags.push('');
		const rScansion = (row["RIVERSIDE_SCANSION"] || "").split(" ");
		let oScansion = oxfordScansionEdits[lineId] || (row["OXFORD_SCANSION"] || "").split(" ");
		while (oScansion.length < oText.length) oScansion.push('');

		// Get original text
		const rOriginal = row["OG_RIV_TEXT"] || "";
		const oOriginal = row["OG_OXFORD_TEXT"] || "";

		riversidePane.innerHTML = createLinePane(rText, rScansion, rTags, false, null, rOriginal);
		oxfordPane.innerHTML = createLinePane(oText, oScansion, oTags, true, lineId, oOriginal);

		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
	  }

	  function navigateLine(offset) {
		if (csvData.length === 0 || currentLine === null) return;
		let index = csvData.findIndex(r => getLineId(r["LINE_NUMBER"]) === getLineId(currentLine));
		if (index === -1) return;
		index = (index + offset + csvData.length) % csvData.length;
		displayLine(csvData[index]["LINE_NUMBER"]);
	  }

	  function navigateDiff(offset) {
		if (!csvData.length || currentLine === null) return;

		const diffLines = csvData
		  .filter(row => row["MATCH"] === "DIFF")
		  .map(row => row["LINE_NUMBER"])
		  .filter(lineNum => {
			if (!hideGreenFlags.checked) return true;
			return lineFlags[getLineId(lineNum)] !== "green";
		  });

		if (!diffLines.length) return;

		const currentIndex = diffLines.findIndex(
		  lineNum => getLineId(lineNum) === getLineId(currentLine)
		);

		if (currentIndex === -1) {
		  displayLine(diffLines[0]);
		  return;
		}

		const newIndex = currentIndex + offset;
		if (newIndex >= 0 && newIndex < diffLines.length) {
		  displayLine(diffLines[newIndex]);
		}
	  }

	  function createLinePane(words, scansion, tags, editable = false, lineId = null, originalText = "") {
		let html = "";
		
		// Ensure edit mode is properly set
		const isEditMode = editMode && editable;
		
		if (toggleOriginal.checked && originalText && originalText.trim()) {
		  html += `<div class="original-text">
			<div class="original-label">Original:</div>
			${originalText}
		  </div>`;
		}
		
		const wordBlocks = words.map((word, i) => {
		  const editableClass = isEditMode ? 'editable' : '';
		  const scanText = scansion[i] || '';
		  const scan = toggleScansion.checked 
			? `<span class="scansion ${editableClass}" data-type="scansion" data-index="${i}" data-line="${lineId}">${scanText}</span>` 
			: "";
		  
		  const tagText = tags[i] || '';
		  const displayTagText = tagText === '' ? '(no tag)' : tagText;
		  const tagClass = tagText === '' ? 'tag no-tag' : 'tag';
		  const tag = toggleTags.checked
			? `<span class="${tagClass}" data-word="${word}" data-index="${i}" data-line="${lineId}">${displayTagText}</span>`
			: "";
		  
		  const wordControls = isEditMode 
			? `<span class="word-controls">
				<button class="word-control-btn add-before" data-action="add" data-line="${lineId}" data-index="${i}" title="Add word before">+</button>
				<button class="word-control-btn" data-action="remove" data-line="${lineId}" data-index="${i}" title="Remove word">-</button>
			   </span>`
			: "";
		  
		  return `<div class="word-block">
			${wordControls}
			${scan}
			${tag}
			<span class="word ${editableClass}" data-type="word" data-index="${i}" data-line="${lineId}">${word}</span>
		  </div>`;
		}).join(" ");
		
		html += wordBlocks;
		
		if (isEditMode) {
		  html += ` <button class="add-word-btn" data-action="add-end" data-line="${lineId}">+ Add Word at End</button>`;
		}
		
		return html;
	  }

	  // Word manipulation functions
	  function addWordBefore(lineId, index) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 0, newWord.trim());
		  oxfordTagEdits[lineId].splice(index, 0, '');
		  oxfordScansionEdits[lineId].splice(index, 0, '');
		  
		  displayLine(currentLine);
		}
	  }

	  function addWordAtEnd(lineId) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].push(newWord.trim());
		  oxfordTagEdits[lineId].push('');
		  oxfordScansionEdits[lineId].push('');
		  
		  displayLine(currentLine);
		}
	  }

	  function removeWord(lineId, index) {
		if (confirm("Remove this word?")) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 1);
		  oxfordTagEdits[lineId].splice(index, 1);
		  oxfordScansionEdits[lineId].splice(index, 1);
		  
		  displayLine(currentLine);
		}
	  }

	  function initializeEditArrays(lineId) {
		if (!oxfordTextEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTextEdits[lineId] = (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		}
		if (!oxfordTagEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTagEdits[lineId] = (row["OXFORD_TAGGING"] || "").split(" ");
		}
		if (!oxfordScansionEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordScansionEdits[lineId] = (row["OXFORD_SCANSION"] || "").split(" ");
		}
	  }

	  // Make functions globally available
	  window.addWordBefore = addWordBefore;
	  window.addWordAtEnd = addWordAtEnd;
	  window.removeWord = removeWord;

	  // Click event handlers for inline editing
	  document.body.addEventListener('click', function (e) {
		const el = e.target;
		
		// Handle word control buttons (+, -)
		if (el.classList.contains('word-control-btn')) {
		  const action = el.dataset.action;
		  const lineId = el.dataset.line;
		  const index = parseInt(el.dataset.index);
		  
		  if (action === 'add' && lineId && index !== undefined) {
			addWordBefore(lineId, index);
		  } else if (action === 'remove' && lineId && index !== undefined) {
			removeWord(lineId, index);
		  }
		  return;
		}
		
		// Handle "Add Word at End" button
		if (el.classList.contains('add-word-btn') && el.dataset.line) {
		  addWordAtEnd(el.dataset.line);
		  return;
		}
		
		// Handle tag editing
		if (el.classList.contains('tag') && el.dataset.line) {
		  // Check if we're in edit mode for Oxford pane
		  const isOxfordPane = el.closest('#oxfordPane');
		  if (isOxfordPane) {
			// Always allow tag editing when clicking on tags in Oxford pane
			showTagEditor(el);
		  } else {
			// For Riverside pane, only allow if not in edit mode
			if (!editMode) {
			  showTagEditor(el);
			}
		  }
		  return;
		} 
		
		// Handle inline text/scansion editing in edit mode
		if (el.classList.contains('editable') && el.dataset.line) {
		  // Check if edit mode is enabled and this is in the Oxford pane
		  const isOxfordPane = el.closest('#oxfordPane');
		  if (editMode && isOxfordPane) {
			startInlineEdit(el);
		  }
		  return;
		}
		
		// Close any open tag editors when clicking elsewhere
		if (!el.classList.contains('tag-editor') && !el.closest('.tag-editor')) {
		  const existing = document.querySelector('.tag-editor');
		  if (existing) existing.remove();
		}
	  });

	  function startInlineEdit(element) {
		const currentText = element.textContent;
		const input = document.createElement('input');
		input.className = 'inline-edit';
		input.value = currentText;
		input.style.width = Math.max(50, currentText.length * 8) + 'px';
		
		element.parentNode.replaceChild(input, element);
		input.focus();
		input.select();

		function finishEdit() {
		  const newValue = input.value.trim();
		  element.textContent = newValue;
		  input.parentNode.replaceChild(element, input);
		  
		  // Update the data
		  const lineId = element.dataset.line;
		  const index = parseInt(element.dataset.index);
		  const type = element.dataset.type;
		  
		  initializeEditArrays(lineId);
		  
		  if (type === 'word') {
			oxfordTextEdits[lineId][index] = newValue;
		  } else if (type === 'scansion') {
			oxfordScansionEdits[lineId][index] = newValue;
		  }
		}

		input.addEventListener('blur', finishEdit);
		input.addEventListener('keydown', (e) => {
		  if (e.key === 'Enter') {
			finishEdit();
		  } else if (e.key === 'Escape') {
			element.textContent = currentText;
			input.parentNode.replaceChild(element, input);
		  }
		});
	  }

	  function showTagEditor(tagEl) {
		const word = tagEl.dataset.word.toLowerCase();
		const index = parseInt(tagEl.dataset.index);
		const lineId = tagEl.dataset.line;

		const rect = tagEl.getBoundingClientRect();
		const editor = document.createElement('div');
		editor.className = 'tag-editor';
		editor.style.top = `${rect.bottom + window.scrollY}px`;
		editor.style.left = `${rect.left + window.scrollX}px`;

		const suggestions = tagSuggestions[word] || {};
		const entries = Object.entries(suggestions);

		if (entries.length > 0) {
		  const sorted = entries.sort((a, b) => b[1] - a[1]);
		  sorted.forEach(([tag, freq]) => {
			const div = document.createElement('div');
			div.textContent = `${tag} (${freq})`;
			div.onclick = () => {
			  updateTag(lineId, index, tag);
			  editor.remove();
			};
			editor.appendChild(div);
		  });
		}

		// Add Riverside suggestions if enabled
		if (useRiversideSuggestions.checked) {
		  const row = findRowByLineNumber(lineId);
		  if (row) {
			const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ").filter(t => t.trim());
			const oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ").filter(t => t.trim());
			
			// Find all tags in Riverside
			const riversideTagsSet = new Set(rTags);
			
			// Remove tags that are already in Oxford
			oTags.forEach(tag => {
			  riversideTagsSet.delete(tag);
			});
			
			// Add a separator if there are both JSON suggestions and Riverside suggestions
			if (entries.length > 0 && riversideTagsSet.size > 0) {
			  const separator = document.createElement('div');
			  separator.style.borderTop = '1px solid var(--border-color)';
			  separator.style.margin = '4px 0';
			  separator.style.padding = '2px 6px';
			  separator.style.fontWeight = 'bold';
			  separator.style.fontSize = '0.85em';
			  separator.style.color = '#666';
			  separator.textContent = 'From Riverside:';
			  separator.style.cursor = 'default';
			  editor.appendChild(separator);
			}
			
			// Add Riverside suggestions
			Array.from(riversideTagsSet).forEach(tag => {
			  const div = document.createElement('div');
			  div.textContent = `${tag} (from Riverside)`;
			  div.style.fontStyle = 'italic';
			  div.onclick = () => {
				updateTag(lineId, index, tag);
				editor.remove();
			  };
			  editor.appendChild(div);
			});
		  }
		}

		// Allow custom input
		const input = document.createElement('input');
		input.className = 'tag-input';
		input.placeholder = 'Custom tag...';
		input.onkeydown = (e) => {
		  if (e.key === 'Enter') {
			updateTag(lineId, index, input.value.trim());
			editor.remove();
		  }
		};
		editor.appendChild(input);

		document.body.appendChild(editor);
		input.focus();
	  }

	  function updateTag(lineId, index, tag) {
		const row = findRowByLineNumber(lineId);
		if (!row) return;
		
		let tags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		const textWords = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(word => word && word.trim());
		while (tags.length < textWords.length) tags.push('');
		tags[index] = tag;
		oxfordTagEdits[lineId] = tags;
		displayLine(currentLine);
	  }

	  // Call refreshEditMode on page load to ensure proper initialization
	  document.addEventListener('DOMContentLoaded', refreshEditMode);
	</script>
  </body>
</html>
