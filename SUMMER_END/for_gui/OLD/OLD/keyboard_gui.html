<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8" />
	<title>Enhanced Text Comparison Viewer</title>
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<style>
:root {
  --bg-color: #ffffff;
  --text-color: #000000;
  --panel-bg: #f8f8f8;
  --border-color: #cccccc;
  --accent-color: #007acc;
  --hover-bg: #f0f0f0;
  --original-bg: #f9f9f9;
  --diff-list-bg: #f9f9f9;
  --controls-bg: #f5f5f5;
  --edit-mode-bg: #fff3cd;
  --edit-mode-border: #ffeaa7;
  --word-mode-bg: #e3f2fd;
  --word-mode-border: #2196f3;
}

.dark-mode {
  --bg-color: #1a1a1a;
  --text-color: #e0e0e0;
  --panel-bg: #2d2d2d;
  --border-color: #444444;
  --accent-color: #4dabf7;
  --hover-bg: #3d3d3d;
  --original-bg: #2a2a2a;
  --diff-list-bg: #2a2a2a;
  --controls-bg: #2d2d2d;
  --edit-mode-bg: #3d3c1a;
  --edit-mode-border: #5d5a2a;
  --word-mode-bg: #1a2a3d;
  --word-mode-border: #4dabf7;
}

body {
  margin: 1em;
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s, color 0.3s;
}

.controls {
  margin-bottom: 1em;
  background: var(--controls-bg);
  border-radius: 4px;
  padding: 8px;
  border: 1px solid var(--border-color);
}

.viewer {
  display: flex;
  height: 50vh;
  border: 1px solid var(--border-color);
  overflow: auto;
  border-radius: 4px;
  background-color: var(--panel-bg);
}

.pane-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
}

.pane-title {
  padding: 8px;
  font-weight: bold;
  text-align: center;
  border-bottom: 1px solid var(--border-color);
  background: var(--panel-bg);
}

.pane {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
}

.original-text {
  background: var(--original-bg);
  padding: 8px;
  margin-bottom: 10px;
  border-left: 3px solid var(--accent-color);
  font-style: italic;
  border-radius: 3px;
}

.original-label {
  font-size: 0.8em;
  color: var(--text-color);
  opacity: 0.7;
  font-weight: bold;
  margin-bottom: 4px;
}

.word-block {
  display: inline-block;
  margin: 4px;
  text-align: center;
  padding: 4px;
  border-radius: 3px;
  transition: background-color 0.2s;
  position: relative;
}

.word-block:hover {
  background-color: var(--hover-bg);
}

.word-block.selected {
  background-color: var(--accent-color);
  color: white;
  outline: 2px solid var(--accent-color);
}

.word-block.selected .scansion,
.word-block.selected .tag {
  color: white;
  opacity: 0.9;
}

.word-block span {
  display: block;
  font-size: 0.75em;
  cursor: pointer;
}

.scansion {
  color: #888;
}

.dark-mode .scansion {
  color: #aaa;
}

.scansion.editable {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  padding: 1px 3px;
  border-radius: 2px;
  min-width: 20px;
  cursor: text;
}

.scansion.editable:hover {
  background: var(--hover-bg);
}

.tag {
  color: var(--accent-color);
  cursor: pointer;
}

.tag.no-tag {
  color: #bbb;
  font-style: italic;
  cursor: pointer;
}

.dark-mode .tag.no-tag {
  color: #888;
}

.word {
  font-weight: bold;
}

.word.editable {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  padding: 2px 4px;
  border-radius: 2px;
  cursor: text;
  min-width: 30px;
}

.word.editable:hover {
  background: var(--hover-bg);
}

.word-controls {
  display: inline-flex;
  gap: 2px;
  margin-right: 4px;
  vertical-align: middle;
}

.word-control-btn {
  background: var(--accent-color);
  color: white;
  border: none;
  font-size: 0.75em;
  padding: 2px 5px;
  border-radius: 2px;
  cursor: pointer;
  min-width: 22px;
}

.word-control-btn:hover {
  opacity: 0.9;
}

.word-control-btn.add-before {
  background: #28a745;
}

.add-word-btn {
  display: inline-block;
  background: #28a745;
  color: white;
  border: none;
  font-size: 0.8em;
  padding: 2px 6px;
  margin: 2px;
  border-radius: 3px;
  cursor: pointer;
  vertical-align: middle;
}

.add-word-btn:hover {
  opacity: 0.9;
}

.tag-editor {
  position: absolute;
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  z-index: 1000;
  padding: 4px;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  min-width: 150px;
  border-radius: 4px;
}

.tag-editor div {
  padding: 2px 6px;
  cursor: pointer;
}

.tag-editor div:hover {
  background: var(--hover-bg);
}

.diff-list {
  max-width: 100%;
  overflow-x: auto;
  white-space: nowrap;
  margin-bottom: 10px;
  padding: 8px;
  border-bottom: 1px solid var(--border-color);
  background: var(--diff-list-bg);
  border-radius: 4px;
}

.line-number {
  cursor: pointer;
  margin-right: 8px;
  color: #900;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 3px;
  white-space: nowrap;
}

.dark-mode .line-number {
  color: #ff6b6b;
}

.line-number:hover {
  background: var(--hover-bg);
}

input.tag-input {
  width: 100%;
  box-sizing: border-box;
  margin-top: 6px;
  padding: 4px 6px;
  font-size: 0.9em;
  border: 1px solid var(--border-color);
  border-radius: 2px;
  background: var(--bg-color);
  color: var(--text-color);
}

.navigation, .diff-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin-top: 12px;
  padding: 8px;
  background: var(--controls-bg);
  border-radius: 4px;
  border: 1px solid var(--border-color);
}

#flagBtn {
  font-size: 1.3em;
  cursor: pointer;
}

.line-display {
  font-size: 1.1em;
  font-weight: bold;
  margin: 0 10px;
  min-width: 300px;
  overflow: visible;
  white-space: normal;
  text-align: center;
}

.flag {
  cursor: pointer;
  font-size: 1.1em;
  margin-left: 4px;
  user-select: none;
  transition: transform 0.2s;
}

.flag:hover {
  transform: scale(1.2);
}

.flag.green {
  color: green;
}

.flag.red {
  color: red;
}

button {
  padding: 6px 12px;
  background: var(--hover-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
  color: var(--text-color);
}

button:hover {
  background: var(--panel-bg);
}

label {
  margin-right: 15px;
}

.edit-mode-controls {
  margin-top: 10px;
  padding: 8px;
  background: var(--edit-mode-bg);
  border: 1px solid var(--edit-mode-border);
  border-radius: 4px;
}

.word-mode-controls {
  margin-top: 10px;
  padding: 8px;
  background: var(--word-mode-bg);
  border: 2px solid var(--word-mode-border);
  border-radius: 4px;
  font-weight: bold;
}

.inline-edit {
  background: var(--edit-mode-bg);
  border: 1px solid var(--border-color);
  padding: 2px 4px;
  border-radius: 2px;
  font-size: inherit;
  font-family: inherit;
  min-width: 20px;
  color: var(--text-color);
}

.dark-mode-toggle {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  background: var(--controls-bg);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 0.9em;
  color: var(--text-color);
}

.dark-mode-toggle:hover {
  background: var(--hover-bg);
}

.keyboard-shortcuts-panel {
  position: fixed;
  top: 50px;
  right: 10px;
  z-index: 999;
  background: var(--controls-bg);
  border: 2px solid var(--accent-color);
  border-radius: 6px;
  padding: 12px;
  max-width: 600px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.keyboard-shortcuts-panel h3 {
  margin: 0 0 10px 0;
  color: var(--accent-color);
}

.shortcuts-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 12px;
  font-size: 0.9em;
  line-height: 1.6;
}

.shortcuts-grid > div:nth-child(odd) {
  font-weight: bold;
  color: var(--accent-color);
}

kbd {
  background: var(--bg-color);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  padding: 2px 6px;
  font-family: monospace;
  font-size: 0.9em;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.help-toggle {
  position: fixed;
  top: 10px;
  right: 140px;
  z-index: 1000;
  background: var(--accent-color);
  color: white;
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  cursor: pointer;
  font-size: 1.2em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}

.help-toggle:hover {
  opacity: 0.9;
  transform: scale(1.05);
}

input[type="text"], input[type="file"] {
  background: var(--bg-color);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  padding: 4px;
}

input[type="checkbox"] {
  margin-right: 5px;
}
	</style>
  </head>
  <body>

	<button class="help-toggle" id="helpToggle" title="Show/Hide Keyboard Shortcuts (?)">?</button>
	<button class="dark-mode-toggle" id="darkModeToggle">üåô Dark Mode</button>

	<div class="controls">
	  <label>CSV File: <input type="file" id="csvFile" accept=".csv" /></label>
	  <label>Tag JSON: <input type="file" id="tagJsonFile" accept=".json" /></label>
	  <button id="export">Export CSV</button>
	  <label><input type="checkbox" id="toggleScansion" checked /> Show Scansion</label>
	  <label><input type="checkbox" id="toggleTags" checked /> Show Tags</label>
	  <label><input type="checkbox" id="toggleOriginal" checked /> Show Original Text</label>
	  <label><input type="checkbox" id="editMode" /> Edit Mode</label>
	  <label><input type="checkbox" id="useRiversideSuggestions" /> Use Riverside Tag Suggestions</label>
	  <label>
	  	<input type="checkbox" id="hideGreenFlags" />
		  Hide Green-Flagged Lines
	  </label>
	</div>

	<div class="edit-mode-controls" id="editModeControls" style="display: none;">
	  <strong>Edit Mode Active:</strong> Click green + to add word before, blue - to remove word, or click text/scansion to edit
	</div>

	<div class="word-mode-controls" id="wordModeControls" style="display: none;">
	  <strong>üéØ WORD MODE (Press ESC to exit):</strong> Tab/Shift+Tab to navigate | Enter to edit | Delete to remove | + to add before | T to edit tag | S to edit scansion
	</div>

	<div class="keyboard-shortcuts-panel" id="keyboardShortcuts" style="display: none;">
	  <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
	  <div class="shortcuts-grid">
		<div><strong>Mode Control:</strong></div>
		<div>
		  <kbd>I</kbd> Enter Word Mode (select first word in Oxford pane) |
		  <kbd>ESC</kbd> Exit Word Mode (return to line navigation)
		</div>
		<div><strong>Line Navigation Mode:</strong></div>
		<div>
		  <kbd>‚Üê</kbd> or <kbd>J</kbd> Previous Line |
		  <kbd>‚Üí</kbd> or <kbd>K</kbd> Next Line
		</div>
		<div>
		  <kbd>Shift</kbd>+<kbd>‚Üê</kbd> or <kbd>Shift</kbd>+<kbd>J</kbd> Previous Diff |
		  <kbd>Shift</kbd>+<kbd>‚Üí</kbd> or <kbd>Shift</kbd>+<kbd>K</kbd> Next Diff
		</div>
		<div>
		  <kbd>F</kbd> Toggle Flag | <kbd>G</kbd> Green Flag | <kbd>R</kbd> Red Flag
		</div>
		<div><strong>Word Mode:</strong></div>
		<div>
		  <kbd>Tab</kbd> Next Word | <kbd>Shift</kbd>+<kbd>Tab</kbd> Previous Word
		</div>
		<div>
		  <kbd>Enter</kbd> Edit Word | <kbd>T</kbd> Edit Tag | <kbd>S</kbd> Edit Scansion
		</div>
		<div>
		  <kbd>Delete</kbd> or <kbd>Backspace</kbd> Remove Word | <kbd>+</kbd> Add Word Before
		</div>
		<div><strong>Other:</strong></div>
		<div>
		  <kbd>?</kbd> Toggle This Help
		</div>
	  </div>
	</div>

	<div class="navigation">
	  <button id="prevLine">Previous</button>
	  <span class="line-display" id="currentLineDisplay">Line: ‚Äì</span>
	  <button id="nextLine">Next</button>
	</div>

	<div class="diff-controls">
	  <button id="prevDiff">Previous Difference</button>
	  <span id="flagBtn" class="flag" title="Click to toggle flag on current line">‚öë</span>
	  <button id="nextDiff">Next Difference</button>
	</div>

	<div class="diff-list" id="diffList"></div>

	<div class="viewer">
	  <div class="pane-container">
		<div class="pane-title">Riverside</div>
		<div class="pane" id="riversidePane"></div>
	  </div>
	  <div class="pane-container">
		<div class="pane-title">Oxford</div>
		<div class="pane" id="oxfordPane"></div>
	  </div>
	</div>

	<script>
	  let csvData = [];
	  let tagSuggestions = {};
	  let oxfordTagEdits = {};
	  let oxfordTextEdits = {};
	  let oxfordScansionEdits = {};
	  let currentLine = null;
	  let lineFlags = {};
	  let editMode = false;
	  let darkMode = false;
	  let selectedWordIndex = null;
	  let wordMode = false;

	  const riversidePane = document.getElementById('riversidePane');
	  const oxfordPane = document.getElementById('oxfordPane');
	  const toggleScansion = document.getElementById('toggleScansion');
	  const toggleTags = document.getElementById('toggleTags');
	  const toggleOriginal = document.getElementById('toggleOriginal');
	  const editModeCheckbox = document.getElementById('editMode');
	  const hideGreenFlags = document.getElementById('hideGreenFlags');
	  const editModeControls = document.getElementById('editModeControls');
	  const wordModeControls = document.getElementById('wordModeControls');
	  const currentLineDisplay = document.getElementById('currentLineDisplay');
	  const useRiversideSuggestions = document.getElementById('useRiversideSuggestions');
	  const darkModeToggle = document.getElementById('darkModeToggle');
	  const helpToggle = document.getElementById('helpToggle');
	  const keyboardShortcuts = document.getElementById('keyboardShortcuts');

	  helpToggle.addEventListener('click', () => {
		keyboardShortcuts.style.display = keyboardShortcuts.style.display === 'none' ? 'block' : 'none';
	  });

	  darkModeToggle.addEventListener('click', () => {
		darkMode = !darkMode;
		if (darkMode) {
		  document.body.classList.add('dark-mode');
		  darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
		} else {
		  document.body.classList.remove('dark-mode');
		  darkModeToggle.textContent = 'üåô Dark Mode';
		}
	  });

	  function getLineId(lineNumber) {
		return String(lineNumber).trim();
	  }

	  function findRowByLineNumber(lineNumber) {
		const searchId = getLineId(lineNumber);
		return csvData.find(r => getLineId(r["LINE_NUMBER"]) === searchId);
	  }

	  editModeCheckbox.addEventListener('change', (e) => {
		editMode = e.target.checked;
		editModeControls.style.display = editMode ? 'block' : 'none';
		if (currentLine) displayLine(currentLine);
	  });

	  hideGreenFlags.addEventListener('change', () => {
	    showDiffList();
	  });

	  document.getElementById('csvFile').addEventListener('change', (e) => {
		const file = e.target.files[0];
		Papa.parse(file, {
		  header: true,
		  skipEmptyLines: true,
		  complete: function(results) {
			csvData = results.data;
			lineFlags = {};
			oxfordTagEdits = {};
			oxfordTextEdits = {};
			oxfordScansionEdits = {};
			
			for (const row of csvData) {
			  const lineId = getLineId(row["LINE_NUMBER"]);
			  const color = (row["FLAG_COLOR"] || "").toLowerCase();
			  if (color === "green" || color === "red") {
				lineFlags[lineId] = color;
			  }
			}
			showDiffList();
			if (csvData.length > 0) {
			  displayLine(csvData[0]["LINE_NUMBER"]);
			}
		  }
		});
	  });

	  document.getElementById('tagJsonFile').addEventListener('change', (e) => {
		const reader = new FileReader();
		reader.onload = () => {
		  try {
			tagSuggestions = JSON.parse(reader.result);
		  } catch (err) {
			alert('Error parsing JSON tag suggestions: ' + err.message);
			tagSuggestions = {};
		  }
		};
		reader.readAsText(e.target.files[0]);
	  });

	  document.getElementById('export').addEventListener('click', () => {
		const updatedCSV = csvData.map(row => {
		  const lineId = getLineId(row["LINE_NUMBER"]);
		  if (oxfordTagEdits[lineId]) {
			row["OXFORD_TAGGING"] = oxfordTagEdits[lineId].join(" ");
		  }
		  if (oxfordTextEdits[lineId]) {
			row["OXFORD_TEXT"] = oxfordTextEdits[lineId].join(" ");
		  }
		  if (oxfordScansionEdits[lineId]) {
			row["OXFORD_SCANSION"] = oxfordScansionEdits[lineId].join(" ");
		  }
		  row["FLAG_COLOR"] = lineFlags[lineId] || "";
		  return row;
		});

		const csv = Papa.unparse(updatedCSV);
		const blob = new Blob([csv], {type: 'text/csv'});
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = 'updated_output.csv';
		a.click();
		URL.revokeObjectURL(url);
	  });

	  toggleScansion.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleTags.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleOriginal.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });

	  document.getElementById('prevLine').addEventListener('click', () => {
		navigateLine(-1);
	  });
	  document.getElementById('nextLine').addEventListener('click', () => {
		navigateLine(1);
	  });
	  document.getElementById('prevDiff').addEventListener('click', () => {
		navigateDiff(-1);
	  });
	  document.getElementById('nextDiff').addEventListener('click', () => {
		navigateDiff(1);
	  });
	  
	  const flagBtn = document.getElementById("flagBtn");
	  flagBtn.style.fontSize = "1.4em";
	  flagBtn.style.cursor = "pointer";
	  flagBtn.style.marginLeft = "10px";

	  flagBtn.onclick = () => {
		toggleFlag(currentLine);
		const lineId = getLineId(currentLine);
		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
		showDiffList();
	  };

	  document.addEventListener('keydown', (e) => {
		if (e.target.tagName === 'INPUT' || e.target.classList.contains('inline-edit')) {
		  return;
		}

		if (e.key === 'Escape' && wordMode) {
		  e.preventDefault();
		  exitWordMode();
		  return;
		}

		if (e.key === '?') {
		  e.preventDefault();
		  helpToggle.click();
		  return;
		}

		if (wordMode) {
		  handleWordModeKey(e);
		} else {
		  handleLineModeKey(e);
		}
	  });

	  function handleLineModeKey(e) {
		if (e.key.toLowerCase() === 'i') {
		  e.preventDefault();
		  enterWordMode();
		}
		else if ((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'j') && !e.shiftKey) {
		  e.preventDefault();
		  navigateLine(-1);
		} else if ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'k') && !e.shiftKey) {
		  e.preventDefault();
		  navigateLine(1);
		} else if ((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'j') && e.shiftKey) {
		  e.preventDefault();
		  navigateDiff(-1);
		} else if ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'k') && e.shiftKey) {
		  e.preventDefault();
		  navigateDiff(1);
		}
		else if (e.key.toLowerCase() === 'f') {
		  e.preventDefault();
		  if (currentLine) {
			toggleFlag(currentLine);
			const lineId = getLineId(currentLine);
			flagBtn.className = "flag " + (lineFlags[lineId] || "");
			flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
			showDiffList();
		  }
		} else if (e.key.toLowerCase() === 'g') {
		  e.preventDefault();
		  if (currentLine) {
			const lineId = getLineId(currentLine);
			lineFlags[lineId] = "green";
			flagBtn.className = "flag green";
			flagBtn.textContent = getFlagSymbol("green");
			showDiffList();
		  }
		} else if (e.key.toLowerCase() === 'r') {
		  e.preventDefault();
		  if (currentLine) {
			const lineId = getLineId(currentLine);
			lineFlags[lineId] = "red";
			flagBtn.className = "flag red";
			flagBtn.textContent = getFlagSymbol("red");
			showDiffList();
		  }
		}
	  }

	  function handleWordModeKey(e) {
		if (e.key === 'Tab') {
		  e.preventDefault();
		  if (e.shiftKey) {
			navigateWord(-1);
		  } else {
			navigateWord(1);
		  }
		}
		else if (e.key === 'Enter') {
		  e.preventDefault();
		  editSelectedElement('word');
		}
		else if (e.key.toLowerCase() === 't') {
		  e.preventDefault();
		  editSelectedElement('tag');
		}
		else if (e.key.toLowerCase() === 's') {
		  e.preventDefault();
		  editSelectedElement('scansion');
		}
		else if (e.key === 'Delete' || e.key === 'Backspace') {
		  e.preventDefault();
		  if (selectedWordIndex !== null) {
			const lineId = getLineId(currentLine);
			if (confirm("Remove this word?")) {
			  removeWord(lineId, selectedWordIndex);
			}
		  }
		}
		else if (e.key === '+' || e.key === '=') {
		  e.preventDefault();
		  if (selectedWordIndex !== null) {
			const lineId = getLineId(currentLine);
			addWordBefore(lineId, selectedWordIndex);
		  }
		}
	  }

	  function enterWordMode() {
		if (!currentLine) return;
		
		const lineId = getLineId(currentLine);
		const row = findRowByLineNumber(lineId);
		if (!row) return;
		
		const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		if (oText.length === 0) return;
		
		wordMode = true;
		selectedWordIndex = 0;
		wordModeControls.style.display = 'block';
		updateWordSelection();
		scrollToSelectedWord();
	  }

	  function exitWordMode() {
		wordMode = false;
		selectedWordIndex = null;
		wordModeControls.style.display = 'none';
		updateWordSelection();
	  }

	  function showDiffList() {
	    const container = document.getElementById('diffList');
	    container.innerHTML = "Lines with differences: ";

	    csvData.forEach(row => {
	      if (row["MATCH"] !== "DIFF") return;

	      const lineNum = row["LINE_NUMBER"];
	      const lineId = getLineId(lineNum);
	      const flag = lineFlags[lineId];

	      if (hideGreenFlags.checked && flag === "green") return;

	      const span = document.createElement("span");
	      span.className = "line-number";
	      span.textContent = lineNum;
	      span.onclick = () => displayLine(lineNum);

	      const flagEl = document.createElement("span");
	      flagEl.className = "flag";
	      flagEl.textContent = getFlagSymbol(flag);
	      flagEl.classList.add(flag);
	      flagEl.onclick = (e) => {
	        e.stopPropagation();
	        toggleFlag(lineNum);
	        showDiffList();
	      };

	      container.appendChild(flagEl);
	      container.appendChild(span);
	    });
	  }

	  function getFlagSymbol(state) {
		if (state === "green") return "‚úÖ";
		if (state === "red") return "üö©";
		return "‚öê";
	  }

	  function toggleFlag(lineNum) {
		const lineId = getLineId(lineNum);
		const current = lineFlags[lineId];
		if (!current) lineFlags[lineId] = "green";
		else if (current === "green") lineFlags[lineId] = "red";
		else delete lineFlags[lineId];
	  }

	  function displayLine(lineNum) {
		currentLine = lineNum;
		exitWordMode();
		currentLineDisplay.textContent = `Line: ${currentLine}`;
		currentLineDisplay.title = currentLine;
		
		const row = findRowByLineNumber(lineNum);
		if (!row) return;

		const lineId = getLineId(lineNum);

		const rText = (row["RIVERSIDE_TEXT"] || "").split(" ").filter(w => w.trim());
		const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ");
		let oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		while (oTags.length < oText.length) oTags.push('');
		const rScansion = (row["RIVERSIDE_SCANSION"] || "").split(" ");
		let oScansion = oxfordScansionEdits[lineId] || (row["OXFORD_SCANSION"] || "").split(" ");
		while (oScansion.length < oText.length) oScansion.push('');

		const rOriginal = row["OG_RIV_TEXT"] || "";
		const oOriginal = row["OG_OXFORD_TEXT"] || "";

		riversidePane.innerHTML = createLinePane(rText, rScansion, rTags, false, null, rOriginal);
		oxfordPane.innerHTML = createLinePane(oText, oScansion, oTags, true, lineId, oOriginal);

		updateWordSelection();

		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
	  }

	  function navigateLine(offset) {
		if (csvData.length === 0 || currentLine === null) return;
		let index = csvData.findIndex(r => getLineId(r["LINE_NUMBER"]) === getLineId(currentLine));
		if (index === -1) return;
		index = (index + offset + csvData.length) % csvData.length;
		displayLine(csvData[index]["LINE_NUMBER"]);
	  }

	  function navigateDiff(offset) {
	    if (!csvData.length || currentLine === null) return;

	    const diffLines = csvData
	      .filter(row => row["MATCH"] === "DIFF")
	      .map(row => row["LINE_NUMBER"])
	      .filter(lineNum => {
	        if (!hideGreenFlags.checked) return true;
	        return lineFlags[getLineId(lineNum)] !== "green";
	      });

	    if (!diffLines.length) return;

	    const currentIndex = diffLines.findIndex(
	      lineNum => getLineId(lineNum) === getLineId(currentLine)
	    );

	    if (currentIndex === -1) {
	      displayLine(diffLines[0]);
	      return;
	    }

	    const newIndex = currentIndex + offset;
	    if (newIndex >= 0 && newIndex < diffLines.length) {
	      displayLine(diffLines[newIndex]);
	    }
	  }

	  function createLinePane(words, scansion, tags, editable = false, lineId = null, originalText = "") {
		let html = "";
		
		if (toggleOriginal.checked && originalText && originalText.trim()) {
		  html += `<div class="original-text">
			<div class="original-label">Original:</div>
			${originalText}
		  </div>`;
		}
		
		const wordBlocks = words.map((word, i) => {
		  const editableClass = (editable && editMode) ? 'editable' : '';
		  const scanText = scansion[i] || '';
		  const scan = toggleScansion.checked 
			? `<span class="scansion ${editableClass}" data-type="scansion" data-index="${i}" data-line="${lineId}">${scanText}</span>` 
			: "";
		  
		  const tagText = tags[i] || '';
		  const displayTagText = tagText === '' ? '(no tag)' : tagText;
		  const tagClass = tagText === '' ? 'tag no-tag' : 'tag';
		  const tag = toggleTags.checked
			? `<span class="${tagClass}" data-word="${word}" data-index="${i}" data-line="${lineId}">${displayTagText}</span>`
			: "";
		  
		  const wordControls = (editable && editMode) 
			? `<span class="word-controls">
				<button class="word-control-btn add-before" onclick="addWordBefore('${lineId}', ${i})" title="Add word before">+</button>
				<button class="word-control-btn" onclick="removeWord('${lineId}', ${i})" title="Remove word">-</button>
			   </span>`
			: "";
		  
		  return `<div class="word-block" data-word-index="${i}" data-editable="${editable}">
			${wordControls}
			${scan}
			${tag}
			<span class="word ${editableClass}" data-type="word" data-index="${i}" data-line="${lineId}">${word}</span>
		  </div>`;
		}).join(" ");
		
		html += wordBlocks;
		
		if (editable && editMode) {
		  html += ` <button class="add-word-btn" onclick="addWordAtEnd('${lineId}')">+ Add Word at End</button>`;
		}
		
		return html;
	  }

	  function addWordBefore(lineId, index) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 0, newWord.trim());
		  oxfordTagEdits[lineId].splice(index, 0, '');
		  oxfordScansionEdits[lineId].splice(index, 0, '');
		  
		  if (wordMode && selectedWordIndex !== null && selectedWordIndex >= index) {
			selectedWordIndex++;
		  }
		  
		  displayLine(currentLine);
		}
	  }

	  function addWordAtEnd(lineId) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].push(newWord.trim());
		  oxfordTagEdits[lineId].push('');
		  oxfordScansionEdits[lineId].push('');
		  
		  displayLine(currentLine);
		}
	  }

	  function removeWord(lineId, index) {
		if (confirm("Remove this word?")) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 1);
		  oxfordTagEdits[lineId].splice(index, 1);
		  oxfordScansionEdits[lineId].splice(index, 1);
		  
		  if (wordMode && selectedWordIndex !== null) {
			if (selectedWordIndex === index) {
			  if (oxfordTextEdits[lineId].length === 0) {
				exitWordMode();
			  } else if (selectedWordIndex > 0) {
				selectedWordIndex--;
			  }
			} else if (selectedWordIndex > index) {
			  selectedWordIndex--;
			}
		  }
		  
		  displayLine(currentLine);
		}
	  }

	  function initializeEditArrays(lineId) {
		if (!oxfordTextEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTextEdits[lineId] = (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		}
		if (!oxfordTagEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTagEdits[lineId] = (row["OXFORD_TAGGING"] || "").split(" ");
		}
		if (!oxfordScansionEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordScansionEdits[lineId] = (row["OXFORD_SCANSION"] || "").split(" ");
		}
	  }

	  window.addWordBefore = addWordBefore;
	  window.addWordAtEnd = addWordAtEnd;
	  window.removeWord = removeWord;

	  function navigateWord(direction) {
		if (!currentLine) return;
		
		const lineId = getLineId(currentLine);
		const row = findRowByLineNumber(lineId);
		if (!row) return;
		
		const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		const maxIndex = oText.length - 1;
		
		if (maxIndex < 0) {
		  exitWordMode();
		  return;
		}
		
		if (selectedWordIndex === null) {
		  selectedWordIndex = direction > 0 ? 0 : maxIndex;
		} else {
		  selectedWordIndex += direction;
		  if (selectedWordIndex > maxIndex) {
			selectedWordIndex = 0;
		  } else if (selectedWordIndex < 0) {
			selectedWordIndex = maxIndex;
		  }
		}
		
		updateWordSelection();
		scrollToSelectedWord();
	  }

	  function updateWordSelection() {
		const allBlocks = oxfordPane.querySelectorAll('.word-block');
		allBlocks.forEach(block => block.classList.remove('selected'));
		
		if (wordMode && selectedWordIndex !== null) {
		  const selectedBlock = oxfordPane.querySelector(`[data-word-index="${selectedWordIndex}"][data-editable="true"]`);
		  if (selectedBlock) {
			selectedBlock.classList.add('selected');
		  }
		}
	  }

	  function scrollToSelectedWord() {
		if (selectedWordIndex === null) return;
		const selectedBlock = oxfordPane.querySelector(`[data-word-index="${selectedWordIndex}"][data-editable="true"]`);
		if (selectedBlock) {
		  selectedBlock.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
		}
	  }

	  function editSelectedElement(type) {
		if (selectedWordIndex === null || !currentLine) return;
		
		const selectedBlock = oxfordPane.querySelector(`[data-word-index="${selectedWordIndex}"][data-editable="true"]`);
		if (!selectedBlock) return;
		
		let targetElement;
		if (type === 'word') {
		  targetElement = selectedBlock.querySelector('.word.editable');
		} else if (type === 'scansion') {
		  targetElement = selectedBlock.querySelector('.scansion.editable');
		} else if (type === 'tag') {
		  targetElement = selectedBlock.querySelector('.tag');
		}
		
		if (targetElement) {
		  if (type === 'tag') {
			showTagEditor(targetElement);
		  } else {
			startInlineEdit(targetElement);
		  }
		}
	  }

	  document.body.addEventListener('click', function (e) {
		const el = e.target;
		
		if (el.classList.contains('tag') && el.dataset.line && !editMode && !wordMode) {
		  showTagEditor(el);
		} 
		else if ((el.classList.contains('editable')) && editMode && el.dataset.line && !wordMode) {
		  startInlineEdit(el);
		}
		else if (el.classList.contains('tag') && el.dataset.line && editMode && !wordMode) {
		  showTagEditor(el);
		}
		else {
		  const existing = document.querySelector('.tag-editor');
		  if (existing) existing.remove();
		}
	  });

	  function startInlineEdit(element) {
		const currentText = element.textContent;
		const input = document.createElement('input');
		input.className = 'inline-edit';
		input.value = currentText;
		input.style.width = Math.max(50, currentText.length * 8) + 'px';
		
		element.parentNode.replaceChild(input, element);
		input.focus();
		input.select();

		function finishEdit() {
		  const newValue = input.value.trim();
		  element.textContent = newValue;
		  input.parentNode.replaceChild(element, input);
		  
		  const lineId = element.dataset.line;
		  const index = parseInt(element.dataset.index);
		  const type = element.dataset.type;
		  
		  initializeEditArrays(lineId);
		  
		  if (type === 'word') {
			oxfordTextEdits[lineId][index] = newValue;
		  } else if (type === 'scansion') {
			oxfordScansionEdits[lineId][index] = newValue;
		  }
		}

		input.addEventListener('blur', finishEdit);
		input.addEventListener('keydown', (e) => {
		  if (e.key === 'Enter') {
			finishEdit();
			if (wordMode) {
			  updateWordSelection();
			}
		  } else if (e.key === 'Escape') {
			element.textContent = currentText;
			input.parentNode.replaceChild(element, input);
			if (wordMode) {
			  updateWordSelection();
			}
		  }
		});
	  }

	  function showTagEditor(tagEl) {
		const word = tagEl.dataset.word.toLowerCase();
		const index = parseInt(tagEl.dataset.index);
		const lineId = tagEl.dataset.line;

		const rect = tagEl.getBoundingClientRect();
		const editor = document.createElement('div');
		editor.className = 'tag-editor';
		editor.style.top = `${rect.bottom + window.scrollY}px`;
		editor.style.left = `${rect.left + window.scrollX}px`;

		const suggestions = tagSuggestions[word] || {};
		const entries = Object.entries(suggestions);

		if (entries.length > 0) {
		  const sorted = entries.sort((a, b) => b[1] - a[1]);
		  sorted.forEach(([tag, freq]) => {
			const div = document.createElement('div');
			div.textContent = `${tag} (${freq})`;
			div.onclick = () => {
			  updateTag(lineId, index, tag);
			  editor.remove();
			};
			editor.appendChild(div);
		  });
		}

		if (useRiversideSuggestions.checked) {
		  const row = findRowByLineNumber(lineId);
		  if (row) {
			const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ").filter(t => t.trim());
			const oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ").filter(t => t.trim());
			
			const riversideTagsSet = new Set(rTags);
			oTags.forEach(tag => {
			  riversideTagsSet.delete(tag);
			});
			
			if (entries.length > 0 && riversideTagsSet.size > 0) {
			  const separator = document.createElement('div');
			  separator.style.borderTop = '1px solid var(--border-color)';
			  separator.style.margin = '4px 0';
			  separator.style.padding = '2px 6px';
			  separator.style.fontWeight = 'bold';
			  separator.style.fontSize = '0.85em';
			  separator.style.color = '#666';
			  separator.textContent = 'From Riverside:';
			  separator.style.cursor = 'default';
			  editor.appendChild(separator);
			}
			
			Array.from(riversideTagsSet).forEach(tag => {
			  const div = document.createElement('div');
			  div.textContent = `${tag} (from Riverside)`;
			  div.style.fontStyle = 'italic';
			  div.onclick = () => {
				updateTag(lineId, index, tag);
				editor.remove();
			  };
			  editor.appendChild(div);
			});
		  }
		}

		const input = document.createElement('input');
		input.className = 'tag-input';
		input.placeholder = 'Custom tag...';
		input.onkeydown = (e) => {
		  if (e.key === 'Enter') {
			updateTag(lineId, index, input.value.trim());
			editor.remove();
		  }
		};
		editor.appendChild(input);

		document.body.appendChild(editor);
		input.focus();
	  }

	  function updateTag(lineId, index, tag) {
		const row = findRowByLineNumber(lineId);
		if (!row) return;
		
		let tags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		const textWords = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(word => word && word.trim());
		while (tags.length < textWords.length) tags.push('');
		tags[index] = tag;
		oxfordTagEdits[lineId] = tags;
		displayLine(currentLine);
	  }
	</script>
  </body>
</html>
