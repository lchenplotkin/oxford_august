<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enhanced Text Comparison Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
body {
  margin: 1em;
}
    .controls {
      margin-bottom: 1em;
      background: #f5f5f5;
      border-radius: 4px;
      padding: 8px;
    }
    .viewer {
      display: flex;
      height: 50vh;
      border: 1px solid #ccc;
      overflow: auto;
      border-radius: 4px;
    }
    .dictionary-section {
      margin-top: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f9f9f9;
    }
    .dictionary-header {
      padding: 8px;
      background: #e8e8e8;
      border-bottom: 1px solid #ccc;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .dictionary-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .dictionary-frame {
      width: 100%;
      height: 300px;
      border: none;
      background: white;
      transform-origin: 0 0;
    }
    .zoom-controls {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    .zoom-btn {
      padding: 2px 6px;
      font-size: 0.8em;
      min-width: 25px;
    }
    .pane-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #ddd;
    }
    .pane-title {
      padding: 8px;
      font-weight: bold;
      text-align: center;
      border-bottom: 1px solid #ddd;
      background: #f8f8f8;
    }
    .pane {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    .original-text {
      background: #f9f9f9;
      padding: 8px;
      margin-bottom: 10px;
      border-left: 3px solid #007acc;
      font-style: italic;
      border-radius: 3px;
    }
    .original-label {
      font-size: 0.8em;
      color: #666;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .word-block {
      display: inline-block;
      margin: 4px;
      text-align: center;
      padding: 4px;
      border-radius: 3px;
      transition: background-color 0.2s;
      position: relative;
    }
    .word-block:hover {
      background-color: #f8f8f8;
    }
    .word-block span {
      display: block;
      font-size: 0.75em;
      cursor: pointer;
    }
    .scansion {
      color: #888;
    }
    .scansion.editable {
      background: #fff;
      border: 1px solid #ddd;
      padding: 1px 3px;
      border-radius: 2px;
      min-width: 20px;
      cursor: text;
    }
    .scansion.editable:hover {
      background: #f0f0f0;
    }
    .tag {
      color: #06c;
      cursor: pointer;
    }
    .tag.no-tag {
      color: #bbb;
      font-style: italic;
      cursor: pointer;
    }
    .word {
      font-weight: bold;
    }
    .word.editable {
      background: #fff;
      border: 1px solid #ddd;
      padding: 2px 4px;
      border-radius: 2px;
      cursor: text;
      min-width: 30px;
    }
    .word.editable:hover {
      background: #f0f0f0;
    }
    .word-controls {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 2px;
    }
    .word-block:hover .word-controls {
      display: flex;
    }
    .word-control-btn {
      background: #007acc;
      color: white;
      border: none;
      font-size: 0.7em;
      padding: 1px 4px;
      border-radius: 2px;
      cursor: pointer;
    }
    .word-control-btn:hover {
      background: #005fa3;
    }
    .add-word-btn {
      display: inline-block;
      background: #28a745;
      color: white;
      border: none;
      font-size: 0.8em;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
      vertical-align: middle;
    }
    .add-word-btn:hover {
      background: #218838;
    }
    .tag-editor {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      z-index: 1000;
      padding: 4px;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      min-width: 150px;
      border-radius: 4px;
    }
    .tag-editor div {
      padding: 2px 6px;
      cursor: pointer;
    }
    .tag-editor div:hover {
      background: #eee;
    }
    .diff-list {
      max-width: 100%;
      overflow-x: auto;
      white-space: nowrap;
      margin-bottom: 10px;
      padding: 8px;
      border-bottom: 1px solid #ccc;
      background: #f9f9f9;
      border-radius: 4px;
    }

    .line-number {
      cursor: pointer;
      margin-right: 8px;
      color: #900;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
    }
    .line-number:hover {
      background: #f0f0f0;
    }
    input.tag-input {
      width: 100%;
      box-sizing: border-box;
      margin-top: 6px;
      padding: 4px 6px;
      font-size: 0.9em;
      border: 1px solid #ccc;
      border-radius: 2px;
    }
    .navigation, .diff-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      margin-top: 12px;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
    }

    #flagBtn {
      font-size: 1.3em;
      cursor: pointer;
    }

    .line-display {
      font-size: 1.1em;
      font-weight: bold;
      margin: 0 10px;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .flag {
      cursor: pointer;
      font-size: 1.1em;
      margin-left: 4px;
      user-select: none;
      transition: transform 0.2s;
    }
    .flag:hover {
      transform: scale(1.2);
    }
    .flag.green {
      color: green;
    }
    .flag.red {
      color: red;
    }

    button {
      padding: 6px 12px;
      background: #e0e0e0;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:hover {
      background: #d0d0d0;
    }

    label {
      margin-right: 15px;
    }

    .edit-mode-controls {
      margin-top: 10px;
      padding: 8px;
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
    }

    .inline-edit {
      background: #fffacd;
      border: 1px solid #ddd;
      padding: 2px 4px;
      border-radius: 2px;
      font-size: inherit;
      font-family: inherit;
      min-width: 20px;
    }
    </style>
  </head>
  <body>

    <div class="controls">
      <label>CSV File: <input type="file" id="csvFile" accept=".csv" /></label>
      <label>Tag JSON: <input type="file" id="tagJsonFile" accept=".json" /></label>
      <button id="export">Export CSV</button>
      <label><input type="checkbox" id="toggleScansion" checked /> Show Scansion</label>
      <label><input type="checkbox" id="toggleTags" checked /> Show Tags</label>
      <label><input type="checkbox" id="toggleOriginal" checked /> Show Original Text</label>
      <label><input type="checkbox" id="editMode" /> Edit Mode</label>
    </div>

    <div class="edit-mode-controls" id="editModeControls" style="display: none;">
      <strong>Edit Mode Active:</strong> Click on Oxford text/scansion to edit, use +/- buttons to add/remove words
    </div>

    <div class="navigation">
      <button id="prevLine">Previous</button>
      <span class="line-display" id="currentLineDisplay">Line: –</span>
      <button id="nextLine">Next</button>
    </div>

    <div class="diff-controls">
      <button id="prevDiff">Previous Difference</button>
      <span id="flagBtn" class="flag" title="Click to toggle flag on current line">⚑</span>
      <button id="nextDiff">Next Difference</button>
    </div>

    <div class="diff-list" id="diffList"></div>

    <div class="viewer">
      <div class="pane-container">
        <div class="pane-title">Riverside</div>
        <div class="pane" id="riversidePane"></div>
      </div>
      <div class="pane-container">
        <div class="pane-title">Oxford</div>
        <div class="pane" id="oxfordPane"></div>
      </div>
    </div>

    <div class="dictionary-section">
      <div class="dictionary-header">
        Middle English Dictionary
        <div class="dictionary-controls">
          <div class="zoom-controls">
            <button id="zoomOut" class="zoom-btn">-</button>
            <span id="zoomLevel">100%</span>
            <button id="zoomIn" class="zoom-btn">+</button>
          </div>
        </div>
      </div>
      <iframe id="dictionaryFrame" class="dictionary-frame" src="https://middleenglish.library.jhu.edu/search"></iframe>
    </div>

    <script>
      let csvData = [];
      let tagSuggestions = {};
      let oxfordTagEdits = {};
      let oxfordTextEdits = {};
      let oxfordScansionEdits = {};
      let currentLine = null;
      let lineFlags = {};
      let editMode = false;

      const riversidePane = document.getElementById('riversidePane');
      const oxfordPane = document.getElementById('oxfordPane');
      const toggleScansion = document.getElementById('toggleScansion');
      const toggleTags = document.getElementById('toggleTags');
      const toggleOriginal = document.getElementById('toggleOriginal');
      const editModeCheckbox = document.getElementById('editMode');
      const editModeControls = document.getElementById('editModeControls');
      const currentLineDisplay = document.getElementById('currentLineDisplay');
      const dictionaryFrame = document.getElementById('dictionaryFrame');
      const zoomIn = document.getElementById('zoomIn');
      const zoomOut = document.getElementById('zoomOut');
      const zoomLevel = document.getElementById('zoomLevel');
      
      let currentZoom = 1.0;

      // Helper function to create a consistent line identifier
      function getLineId(lineNumber) {
        return String(lineNumber).trim();
      }

      // Helper function to find row by line number (handles various formats)
      function findRowByLineNumber(lineNumber) {
        const searchId = getLineId(lineNumber);
        return csvData.find(r => getLineId(r["LINE_NUMBER"]) === searchId);
      }

      editModeCheckbox.addEventListener('change', (e) => {
        editMode = e.target.checked;
        editModeControls.style.display = editMode ? 'block' : 'none';
        if (currentLine) displayLine(currentLine);
      });

      document.getElementById('csvFile').addEventListener('change', (e) => {
        const file = e.target.files[0];
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            csvData = results.data;
            lineFlags = {};
            oxfordTagEdits = {};
            oxfordTextEdits = {};
            oxfordScansionEdits = {};
            
            for (const row of csvData) {
              const lineId = getLineId(row["LINE_NUMBER"]);
              const color = (row["FLAG_COLOR"] || "").toLowerCase();
              if (color === "green" || color === "red") {
                lineFlags[lineId] = color;
              }
            }
            showDiffList();
            if (csvData.length > 0) {
              displayLine(csvData[0]["LINE_NUMBER"]);
            }
          }
        });
      });

      document.getElementById('tagJsonFile').addEventListener('change', (e) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            tagSuggestions = JSON.parse(reader.result);
          } catch (err) {
            alert('Error parsing JSON tag suggestions: ' + err.message);
            tagSuggestions = {};
          }
        };
        reader.readAsText(e.target.files[0]);
      });

      document.getElementById('export').addEventListener('click', () => {
        const updatedCSV = csvData.map(row => {
          const lineId = getLineId(row["LINE_NUMBER"]);
          if (oxfordTagEdits[lineId]) {
            row["OXFORD_TAGGING"] = oxfordTagEdits[lineId].join(" ");
          }
          if (oxfordTextEdits[lineId]) {
            row["OXFORD_TEXT"] = oxfordTextEdits[lineId].join(" ");
          }
          if (oxfordScansionEdits[lineId]) {
            row["OXFORD_SCANSION"] = oxfordScansionEdits[lineId].join(" ");
          }
          row["FLAG_COLOR"] = lineFlags[lineId] || "";
          return row;
        });

        const csv = Papa.unparse(updatedCSV);
        const blob = new Blob([csv], {type: 'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'updated_output.csv';
        a.click();
        URL.revokeObjectURL(url);
      });

      toggleScansion.addEventListener('change', () => {
        if (currentLine) displayLine(currentLine);
      });
      toggleTags.addEventListener('change', () => {
        if (currentLine) displayLine(currentLine);
      });
      toggleOriginal.addEventListener('change', () => {
        if (currentLine) displayLine(currentLine);
      });

      document.getElementById('prevLine').addEventListener('click', () => {
        navigateLine(-1);
      });
      document.getElementById('nextLine').addEventListener('click', () => {
        navigateLine(1);
      });
      document.getElementById('prevDiff').addEventListener('click', () => {
        navigateDiff(-1);
      });
      document.getElementById('nextDiff').addEventListener('click', () => {
        navigateDiff(1);
      });

      // Zoom controls
      zoomIn.addEventListener('click', () => {
        currentZoom = Math.min(currentZoom + 0.1, 2.0);
        updateZoom();
      });

      zoomOut.addEventListener('click', () => {
        currentZoom = Math.max(currentZoom - 0.1, 0.5);
        updateZoom();
      });

      function updateZoom() {
        dictionaryFrame.style.transform = `scale(${currentZoom})`;
        dictionaryFrame.style.width = `${100 / currentZoom}%`;
        dictionaryFrame.style.height = `${300 / currentZoom}px`;
        zoomLevel.textContent = `${Math.round(currentZoom * 100)}%`;
      }
      
      const flagBtn = document.getElementById("flagBtn");
      flagBtn.style.fontSize = "1.4em";
      flagBtn.style.cursor = "pointer";
      flagBtn.style.marginLeft = "10px";

      flagBtn.onclick = () => {
        toggleFlag(currentLine);
        const lineId = getLineId(currentLine);
        flagBtn.className = "flag " + (lineFlags[lineId] || "");
        flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
        showDiffList();
      };

      function showDiffList() {
        const container = document.getElementById('diffList');
        container.innerHTML = "Lines with differences: ";
        csvData.forEach(row => {
          if (row["MATCH"] === "DIFF") {
            const lineNum = row["LINE_NUMBER"];
            const lineId = getLineId(lineNum);
            const span = document.createElement("span");
            span.className = "line-number";
            span.textContent = lineNum;
            span.onclick = () => displayLine(lineNum);

            const flag = document.createElement("span");
            flag.className = "flag";
            flag.textContent = getFlagSymbol(lineFlags[lineId]);
            flag.classList.add(lineFlags[lineId]);
            flag.onclick = (e) => {
              e.stopPropagation();
              toggleFlag(lineNum);
              showDiffList();
            };

            container.appendChild(flag);
            container.appendChild(span);
          }
        });
      }

      function getFlagSymbol(state) {
        if (state === "green") return "✅";
        if (state === "red") return "🚩";
        return "⚐";
      }

      function toggleFlag(lineNum) {
        const lineId = getLineId(lineNum);
        const current = lineFlags[lineId];
        if (!current) lineFlags[lineId] = "green";
        else if (current === "green") lineFlags[lineId] = "red";
        else delete lineFlags[lineId];
      }

      function displayLine(lineNum) {
        currentLine = lineNum;
        currentLineDisplay.textContent = `Line: ${currentLine}`;
        currentLineDisplay.title = currentLine;
        
        const row = findRowByLineNumber(lineNum);
        if (!row) return;

        const lineId = getLineId(lineNum);

        const rText = (row["RIVERSIDE_TEXT"] || "").split(" ").filter(w => w.trim());
        const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
        const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ");
        let oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
        while (oTags.length < oText.length) oTags.push('');
        const rScansion = (row["RIVERSIDE_SCANSION"] || "").split(" ");
        let oScansion = oxfordScansionEdits[lineId] || (row["OXFORD_SCANSION"] || "").split(" ");
        while (oScansion.length < oText.length) oScansion.push('');

        // Get original text
        const rOriginal = row["OG_RIV_TEXT"] || "";
        const oOriginal = row["OG_OXFORD_TEXT"] || "";

        riversidePane.innerHTML = createLinePane(rText, rScansion, rTags, false, null, rOriginal);
        oxfordPane.innerHTML = createLinePane(oText, oScansion, oTags, true, lineId, oOriginal);

        flagBtn.className = "flag " + (lineFlags[lineId] || "");
        flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);

        // Auto-search for differences in Oxford text
        if (row["MATCH"] === "DIFF") {
          autoSearchDifferences(row);
        }
      }

      function autoSearchDifferences(row) {
        const rWords = (row["RIVERSIDE_TEXT"] || "").toLowerCase().split(" ");
        const oWords = (row["OXFORD_TEXT"] || "").toLowerCase().split(" ");
        
        let differentWord = null;
        const maxLen = Math.max(rWords.length, oWords.length);
        
        for (let i = 0; i < maxLen; i++) {
          const rWord = rWords[i] || "";
          const oWord = oWords[i] || "";
          
          if (rWord !== oWord && oWord) {
            differentWord = oWord.replace(/[.,;:!?"'()]/g, '');
            break;
          }
        }
        
        if (differentWord && differentWord.length > 1) {
          dictionarySearch.value = differentWord;
          searchMiddleEnglishDictionary(differentWord);
        }
      }

      function searchMiddleEnglishDictionary(searchTerm) {
        const baseUrl = 'https://middleenglish.library.jhu.edu/search';
        
        console.log('Searching for:', searchTerm);
        dictionaryFrame.src = baseUrl;
        
        dictionaryFrame.onload = () => {
          try {
            setTimeout(() => {
              const iframeDoc = dictionaryFrame.contentDocument || dictionaryFrame.contentWindow.document;
              const searchInput = iframeDoc.querySelector('input[type="text"]') || 
                                 iframeDoc.querySelector('textarea') ||
                                 iframeDoc.querySelector('#query') ||
                                 iframeDoc.querySelector('[name="q"]');
              
              if (searchInput) {
                searchInput.value = searchTerm;
                searchInput.focus();
                
                const searchButton = iframeDoc.querySelector('button[type="submit"]') ||
                                   iframeDoc.querySelector('input[type="submit"]') ||
                                   iframeDoc.querySelector('.search-button');
                
                if (searchButton) {
                  searchButton.click();
                }
              }
            }, 1000);
          } catch (e) {
            const searchUrl = `${baseUrl}?q=${encodeURIComponent(searchTerm)}&submit=Search`;
            dictionaryFrame.src = searchUrl;
          }
        };
        
        dictionaryFrame.onerror = () => {
          const searchUrl = `${baseUrl}?q=${encodeURIComponent(searchTerm)}`;
          window.open(searchUrl, '_blank');
        };
      }

      function navigateLine(offset) {
        if (csvData.length === 0 || currentLine === null) return;
        let index = csvData.findIndex(r => getLineId(r["LINE_NUMBER"]) === getLineId(currentLine));
        if (index === -1) return;
        index = (index + offset + csvData.length) % csvData.length;
        displayLine(csvData[index]["LINE_NUMBER"]);
      }

      function navigateDiff(offset) {
        if (!csvData.length || currentLine === null) return;
        const diffLines = csvData
          .filter(row => row["MATCH"] === "DIFF")
          .map(row => row["LINE_NUMBER"]);
        const currentIndex = diffLines.findIndex(lineNum => getLineId(lineNum) === getLineId(currentLine));

        if (currentIndex === -1) {
          const first = diffLines[0];
          if (first !== undefined) displayLine(first);
          return;
        }

        const newIndex = currentIndex + offset;
        if (newIndex >= 0 && newIndex < diffLines.length) {
          displayLine(diffLines[newIndex]);
        }
      }

      function createLinePane(words, scansion, tags, editable = false, lineId = null, originalText = "") {
        let html = "";
        
        if (toggleOriginal.checked && originalText && originalText.trim()) {
          html += `<div class="original-text">
            <div class="original-label">Original:</div>
            ${originalText}
          </div>`;
        }
        
        if (editable && editMode) {
          html += ` <button class="add-word-btn" onclick="addWordAtStart('${lineId}')">+ Add Word at Start</button><br><br>`;
        }
        
        const wordBlocks = words.map((word, i) => {
          const editableClass = (editable && editMode) ? 'editable' : '';
          const scanText = scansion[i] || '';
          const scan = toggleScansion.checked 
            ? `<span class="scansion ${editableClass}" data-type="scansion" data-index="${i}" data-line="${lineId}">${scanText}</span>` 
            : "";
          
          const tagText = tags[i] || '';
          const displayTagText = tagText === '' ? '(no tag)' : tagText;
          const tagClass = tagText === '' ? 'tag no-tag' : 'tag';
          const tag = toggleTags.checked
            ? `<span class="${tagClass}" data-word="${word}" data-index="${i}" data-line="${lineId}">${displayTagText}</span>`
            : "";
          
          const wordControls = (editable && editMode) 
            ? `<div class="word-controls">
                <button class="word-control-btn" onclick="removeWord('${lineId}', ${i})">-</button>
                <button class="word-control-btn" onclick="addWordAfter('${lineId}', ${i})">+</button>
               </div>`
            : "";
          
          return `<div class="word-block">
            ${wordControls}
            ${scan}
            ${tag}
            <span class="word ${editableClass}" data-type="word" data-index="${i}" data-line="${lineId}">${word}</span>
          </div>`;
        }).join(" ");
        
        html += wordBlocks;
        
        if (editable && editMode) {
          html += ` <button class="add-word-btn" onclick="addWordAtEnd('${lineId}')">+ Add Word</button>`;
        }
        
        return html;
      }

      // Word manipulation functions
      function addWordAfter(lineId, index) {
        const newWord = prompt("Enter new word:");
        if (newWord && newWord.trim()) {
          initializeEditArrays(lineId);
          
          oxfordTextEdits[lineId].splice(index + 1, 0, newWord.trim());
          oxfordTagEdits[lineId].splice(index + 1, 0, '');
          oxfordScansionEdits[lineId].splice(index + 1, 0, '');
          
          displayLine(currentLine);
        }
      }

      function addWordAtEnd(lineId) {
        const newWord = prompt("Enter new word:");
        if (newWord && newWord.trim()) {
          initializeEditArrays(lineId);
          
          oxfordTextEdits[lineId].push(newWord.trim());
          oxfordTagEdits[lineId].push('');
          oxfordScansionEdits[lineId].push('');
          
          displayLine(currentLine);
        }
      }

      function addWordAtStart(lineId) {
        const newWord = prompt("Enter new word:");
        if (newWord && newWord.trim()) {
          initializeEditArrays(lineId);
          
          oxfordTextEdits[lineId].unshift(newWord.trim());
          oxfordTagEdits[lineId].unshift('');
          oxfordScansionEdits[lineId].unshift('');
          
          displayLine(currentLine);
        }
      }

      function removeWord(lineId, index) {
        if (confirm("Remove this word?")) {
          initializeEditArrays(lineId);
          
          oxfordTextEdits[lineId].splice(index, 1);
          oxfordTagEdits[lineId].splice(index, 1);
          oxfordScansionEdits[lineId].splice(index, 1);
          
          displayLine(currentLine);
        }
      }

      function initializeEditArrays(lineId) {
        if (!oxfordTextEdits[lineId]) {
          const row = findRowByLineNumber(lineId);
          oxfordTextEdits[lineId] = (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
        }
        if (!oxfordTagEdits[lineId]) {
          const row = findRowByLineNumber(lineId);
          oxfordTagEdits[lineId] = (row["OXFORD_TAGGING"] || "").split(" ");
        }
        if (!oxfordScansionEdits[lineId]) {
          const row = findRowByLineNumber(lineId);
          oxfordScansionEdits[lineId] = (row["OXFORD_SCANSION"] || "").split(" ");
        }
      }

      // Make functions globally available
      window.addWordAfter = addWordAfter;
      window.addWordAtEnd = addWordAtEnd;
      window.addWordAtStart = addWordAtStart;
      window.removeWord = removeWord;

      // Click event handlers for inline editing
      document.body.addEventListener('click', function (e) {
        const el = e.target;
        
        // Handle tag editing (existing functionality)
        if (el.classList.contains('tag') && el.dataset.line && !editMode) {
          showTagEditor(el);
        } 
        // Handle inline text/scansion editing in edit mode
        else if ((el.classList.contains('editable')) && editMode && el.dataset.line) {
          startInlineEdit(el);
        }
        // Handle tag editing in edit mode
        else if (el.classList.contains('tag') && el.dataset.line && editMode) {
          showTagEditor(el);
        }
        else {
          // Close any open editors
          const existing = document.querySelector('.tag-editor');
          if (existing) existing.remove();
        }
      });

      function startInlineEdit(element) {
        const currentText = element.textContent;
        const input = document.createElement('input');
        input.className = 'inline-edit';
        input.value = currentText;
        input.style.width = Math.max(50, currentText.length * 8) + 'px';
        
        element.parentNode.replaceChild(input, element);
        input.focus();
        input.select();

        function finishEdit() {
          const newValue = input.value.trim();
          element.textContent = newValue;
          input.parentNode.replaceChild(element, input);
          
          // Update the data
          const lineId = element.dataset.line;
          const index = parseInt(element.dataset.index);
          const type = element.dataset.type;
          
          initializeEditArrays(lineId);
          
          if (type === 'word') {
            oxfordTextEdits[lineId][index] = newValue;
          } else if (type === 'scansion') {
            oxfordScansionEdits[lineId][index] = newValue;
          }
        }

        input.addEventListener('blur', finishEdit);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            finishEdit();
          } else if (e.key === 'Escape') {
            element.textContent = currentText;
            input.parentNode.replaceChild(element, input);
          }
        });
      }

      function showTagEditor(tagEl) {
        const word = tagEl.dataset.word.toLowerCase();
        const index = parseInt(tagEl.dataset.index);
        const lineId = tagEl.dataset.line;

        const rect = tagEl.getBoundingClientRect();
        const editor = document.createElement('div');
        editor.className = 'tag-editor';
        editor.style.top = `${rect.bottom + window.scrollY}px`;
        editor.style.left = `${rect.left + window.scrollX}px`;

        const suggestions = tagSuggestions[word] || {};
        const entries = Object.entries(suggestions);

        if (entries.length > 0) {
          const sorted = entries.sort((a, b) => b[1] - a[1]);
          sorted.forEach(([tag, freq]) => {
            const div = document.createElement('div');
            div.textContent = `${tag} (${freq})`;
            div.onclick = () => {
              updateTag(lineId, index, tag);
              editor.remove();
            };
            editor.appendChild(div);
          });
        }

        // Allow custom input
        const input = document.createElement('input');
        input.className = 'tag-input';
        input.placeholder = 'Custom tag...';
        input.onkeydown = (e) => {
          if (e.key === 'Enter') {
            updateTag(lineId, index, input.value.trim());
            editor.remove();
          }
        };
        editor.appendChild(input);

        document.body.appendChild(editor);
        input.focus();
      }

      function updateTag(lineId, index, tag) {
        const row = findRowByLineNumber(lineId);
        if (!row) return;
        
        let tags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
        const textWords = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(word => word && word.trim());
        while (tags.length < textWords.length) tags.push('');
        tags[index] = tag;
        oxfordTagEdits[lineId] = tags;
        displayLine(currentLine);
      }
    </script>
  </body>
</html>
