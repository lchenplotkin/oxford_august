<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8" />
	<title>Enhanced Text Comparison Viewer</title>
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<style>
body {
  margin: 1em;
}
	.controls {
	  margin-bottom: 1em;
	  background: #f5f5f5;
	  border-radius: 4px;
	  padding: 8px;
	}
	.viewer {
	  display: flex;
	  height: 50vh;
	  border: 1px solid #ccc;
	  overflow: auto;
	  border-radius: 4px;
	}
	.pane-container {
	  flex: 1;
	  display: flex;
	  flex-direction: column;
	  border-right: 1px solid #ddd;
	}
	.pane-title {
	  padding: 8px;
	  font-weight: bold;
	  text-align: center;
	  border-bottom: 1px solid #ddd;
	  background: #f8f8f8;
	}
	.pane {
	  flex: 1;
	  padding: 10px;
	  overflow-y: auto;
	}
	.original-text {
	  background: #f9f9f9;
	  padding: 8px;
	  margin-bottom: 10px;
	  border-left: 3px solid #007acc;
	  font-style: italic;
	  border-radius: 3px;
	}
	.original-label {
	  font-size: 0.8em;
	  color: #666;
	  font-weight: bold;
	  margin-bottom: 4px;
	}
	.word-block {
	  display: inline-block;
	  margin: 4px;
	  text-align: center;
	  padding: 4px;
	  border-radius: 3px;
	  transition: background-color 0.2s;
	  position: relative;
	}
	.word-block:hover {
	  background-color: #f8f8f8;
	}
	.word-block span {
	  display: block;
	  font-size: 0.75em;
	  cursor: pointer;
	}
	.scansion {
	  color: #888;
	}
	.scansion.editable {
	  background: #fff;
	  border: 1px solid #ddd;
	  padding: 1px 3px;
	  border-radius: 2px;
	  min-width: 20px;
	  cursor: text;
	}
	.scansion.editable:hover {
	  background: #f0f0f0;
	}
	.tag {
	  color: #06c;
	  cursor: pointer;
	}
	.tag.no-tag {
	  color: #bbb;
	  font-style: italic;
	  cursor: pointer;
	}
	.word {
	  font-weight: bold;
	}
	.word.editable {
	  background: #fff;
	  border: 1px solid #ddd;
	  padding: 2px 4px;
	  border-radius: 2px;
	  cursor: text;
	  min-width: 30px;
	}
	.word.editable:hover {
	  background: #f0f0f0;
	}
	.word-controls {
	  display: inline-flex;
	  gap: 2px;
	  margin-right: 4px;
	  vertical-align: middle;
	}
	.word-control-btn {
	  background: #007acc;
	  color: white;
	  border: none;
	  font-size: 0.75em;
	  padding: 2px 5px;
	  border-radius: 2px;
	  cursor: pointer;
	  min-width: 22px;
	}
	.word-control-btn:hover {
	  background: #005fa3;
	}
	.word-control-btn.add-before {
	  background: #28a745;
	}
	.word-control-btn.add-before:hover {
	  background: #218838;
	}
	.add-word-btn {
	  display: inline-block;
	  background: #28a745;
	  color: white;
	  border: none;
	  font-size: 0.8em;
	  padding: 2px 6px;
	  margin: 2px;
	  border-radius: 3px;
	  cursor: pointer;
	  vertical-align: middle;
	}
	.add-word-btn:hover {
	  background: #218838;
	}
	.tag-editor {
	  position: absolute;
	  background: white;
	  border: 1px solid #ccc;
	  z-index: 1000;
	  padding: 4px;
	  max-height: 200px;
	  overflow-y: auto;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
	  min-width: 150px;
	  border-radius: 4px;
	}
	.tag-editor div {
	  padding: 2px 6px;
	  cursor: pointer;
	}
	.tag-editor div:hover {
	  background: #eee;
	}
	.diff-list {
	  max-width: 100%;
	  overflow-x: auto;
	  white-space: nowrap;
	  margin-bottom: 10px;
	  padding: 8px;
	  border-bottom: 1px solid #ccc;
	  background: #f9f9f9;
	  border-radius: 4px;
	}

	.line-number {
	  cursor: pointer;
	  margin-right: 8px;
	  color: #900;
	  font-weight: bold;
	  padding: 2px 6px;
	  border-radius: 3px;
	  white-space: nowrap;
	}
	.line-number:hover {
	  background: #f0f0f0;
	}
	input.tag-input {
	  width: 100%;
	  box-sizing: border-box;
	  margin-top: 6px;
	  padding: 4px 6px;
	  font-size: 0.9em;
	  border: 1px solid #ccc;
	  border-radius: 2px;
	}
	.navigation, .diff-controls {
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  gap: 16px;
	  margin-top: 12px;
	  padding: 8px;
	  background: #f5f5f5;
	  border-radius: 4px;
	}

	#flagBtn {
	  font-size: 1.3em;
	  cursor: pointer;
	}

	.line-display {
	  font-size: 1.1em;
	  font-weight: bold;
	  margin: 0 10px;
	  min-width: 300px;
	  overflow: visible;
	  white-space: normal;
	  text-align: center;
	}

	.flag {
	  cursor: pointer;
	  font-size: 1.1em;
	  margin-left: 4px;
	  user-select: none;
	  transition: transform 0.2s;
	}
	.flag:hover {
	  transform: scale(1.2);
	}
	.flag.green {
	  color: green;
	}
	.flag.red {
	  color: red;
	}

	button {
	  padding: 6px 12px;
	  background: #e0e0e0;
	  border: 1px solid #ccc;
	  border-radius: 4px;
	  cursor: pointer;
	  transition: background-color 0.2s;
	}
	button:hover {
	  background: #d0d0d0;
	}

	label {
	  margin-right: 15px;
	}

	.edit-mode-controls {
	  margin-top: 10px;
	  padding: 8px;
	  background: #fff3cd;
	  border: 1px solid #ffeaa7;
	  border-radius: 4px;
	}

	.inline-edit {
	  background: #fffacd;
	  border: 1px solid #ddd;
	  padding: 2px 4px;
	  border-radius: 2px;
	  font-size: inherit;
	  font-family: inherit;
	  min-width: 20px;
	}
	</style>
  </head>
  <body>

	<div class="controls">
	  <label>CSV File: <input type="file" id="csvFile" accept=".csv" /></label>
	  <label>Tag JSON: <input type="file" id="tagJsonFile" accept=".json" /></label>
	  <button id="export">Export CSV</button>
	  <label><input type="checkbox" id="toggleScansion" checked /> Show Scansion</label>
	  <label><input type="checkbox" id="toggleTags" checked /> Show Tags</label>
	  <label><input type="checkbox" id="toggleOriginal" checked /> Show Original Text</label>
	  <label><input type="checkbox" id="editMode" /> Edit Mode</label>
	  <label><input type="checkbox" id="useRiversideSuggestions" /> Use Riverside Tag Suggestions</label>
	  <label>
	  	<input type="checkbox" id="hideGreenFlags" />
		  Hide Green-Flagged Lines
	  </label>

	</div>

	<div class="edit-mode-controls" id="editModeControls" style="display: none;">
	  <strong>Edit Mode Active:</strong> Click green + to add word before, blue - to remove word, or click text/scansion to edit
	</div>

	<div class="navigation">
	  <button id="prevLine">Previous</button>
	  <span class="line-display" id="currentLineDisplay">Line: â€“</span>
	  <button id="nextLine">Next</button>
	</div>

	<div class="diff-controls">
	  <button id="prevDiff">Previous Difference</button>
	  <span id="flagBtn" class="flag" title="Click to toggle flag on current line">âš‘</span>
	  <button id="nextDiff">Next Difference</button>
	</div>

	<div class="diff-list" id="diffList"></div>

	<div class="viewer">
	  <div class="pane-container">
		<div class="pane-title">Riverside</div>
		<div class="pane" id="riversidePane"></div>
	  </div>
	  <div class="pane-container">
		<div class="pane-title">Oxford</div>
		<div class="pane" id="oxfordPane"></div>
	  </div>
	</div>

	<script>
	  let csvData = [];
	  let tagSuggestions = {};
	  let oxfordTagEdits = {};
	  let oxfordTextEdits = {};
	  let oxfordScansionEdits = {};
	  let currentLine = null;
	  let lineFlags = {};
	  let editMode = false;

	  const riversidePane = document.getElementById('riversidePane');
	  const oxfordPane = document.getElementById('oxfordPane');
	  const toggleScansion = document.getElementById('toggleScansion');
	  const toggleTags = document.getElementById('toggleTags');
	  const toggleOriginal = document.getElementById('toggleOriginal');
	  const editModeCheckbox = document.getElementById('editMode');
	  const hideGreenFlags = document.getElementById('hideGreenFlags');
	  const editModeControls = document.getElementById('editModeControls');
	  const currentLineDisplay = document.getElementById('currentLineDisplay');
	  const useRiversideSuggestions = document.getElementById('useRiversideSuggestions');

	  // Helper function to create a consistent line identifier
	  function getLineId(lineNumber) {
		return String(lineNumber).trim();
	  }

	  // Helper function to find row by line number (handles various formats)
	  function findRowByLineNumber(lineNumber) {
		const searchId = getLineId(lineNumber);
		return csvData.find(r => getLineId(r["LINE_NUMBER"]) === searchId);
	  }

	  editModeCheckbox.addEventListener('change', (e) => {
		editMode = e.target.checked;
		editModeControls.style.display = editMode ? 'block' : 'none';
		if (currentLine) displayLine(currentLine);
	  });
	  hideGreenFlags.addEventListener('change', () => {
	    showDiffList();
	  });


	  document.getElementById('csvFile').addEventListener('change', (e) => {
		const file = e.target.files[0];
		Papa.parse(file, {
		  header: true,
		  skipEmptyLines: true,
		  complete: function(results) {
			csvData = results.data;
			lineFlags = {};
			oxfordTagEdits = {};
			oxfordTextEdits = {};
			oxfordScansionEdits = {};
			
			for (const row of csvData) {
			  const lineId = getLineId(row["LINE_NUMBER"]);
			  const color = (row["FLAG_COLOR"] || "").toLowerCase();
			  if (color === "green" || color === "red") {
				lineFlags[lineId] = color;
			  }
			}
			showDiffList();
			if (csvData.length > 0) {
			  displayLine(csvData[0]["LINE_NUMBER"]);
			}
		  }
		});
	  });

	  document.getElementById('tagJsonFile').addEventListener('change', (e) => {
		const reader = new FileReader();
		reader.onload = () => {
		  try {
			tagSuggestions = JSON.parse(reader.result);
		  } catch (err) {
			alert('Error parsing JSON tag suggestions: ' + err.message);
			tagSuggestions = {};
		  }
		};
		reader.readAsText(e.target.files[0]);
	  });

	  document.getElementById('export').addEventListener('click', () => {
		const updatedCSV = csvData.map(row => {
		  const lineId = getLineId(row["LINE_NUMBER"]);
		  if (oxfordTagEdits[lineId]) {
			row["OXFORD_TAGGING"] = oxfordTagEdits[lineId].join(" ");
		  }
		  if (oxfordTextEdits[lineId]) {
			row["OXFORD_TEXT"] = oxfordTextEdits[lineId].join(" ");
		  }
		  if (oxfordScansionEdits[lineId]) {
			row["OXFORD_SCANSION"] = oxfordScansionEdits[lineId].join(" ");
		  }
		  row["FLAG_COLOR"] = lineFlags[lineId] || "";
		  return row;
		});

		const csv = Papa.unparse(updatedCSV);
		const blob = new Blob([csv], {type: 'text/csv'});
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a');
		a.href = url;
		a.download = 'updated_output.csv';
		a.click();
		URL.revokeObjectURL(url);
	  });

	  toggleScansion.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleTags.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });
	  toggleOriginal.addEventListener('change', () => {
		if (currentLine) displayLine(currentLine);
	  });

	  document.getElementById('prevLine').addEventListener('click', () => {
		navigateLine(-1);
	  });
	  document.getElementById('nextLine').addEventListener('click', () => {
		navigateLine(1);
	  });
	  document.getElementById('prevDiff').addEventListener('click', () => {
		navigateDiff(-1);
	  });
	  document.getElementById('nextDiff').addEventListener('click', () => {
		navigateDiff(1);
	  });
	  
	  const flagBtn = document.getElementById("flagBtn");
	  flagBtn.style.fontSize = "1.4em";
	  flagBtn.style.cursor = "pointer";
	  flagBtn.style.marginLeft = "10px";

	  flagBtn.onclick = () => {
		toggleFlag(currentLine);
		const lineId = getLineId(currentLine);
		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
		showDiffList();
	  };

	  function showDiffList() {
	    const container = document.getElementById('diffList');
	    container.innerHTML = "Lines with differences: ";

	    csvData.forEach(row => {
	      if (row["MATCH"] !== "DIFF") return;

	      const lineNum = row["LINE_NUMBER"];
	      const lineId = getLineId(lineNum);
	      const flag = lineFlags[lineId];

	      // NEW: skip green-flagged lines if toggle is on
	      if (hideGreenFlags.checked && flag === "green") return;

	      const span = document.createElement("span");
	      span.className = "line-number";
	      span.textContent = lineNum;
	      span.onclick = () => displayLine(lineNum);

	      const flagEl = document.createElement("span");
	      flagEl.className = "flag";
	      flagEl.textContent = getFlagSymbol(flag);
	      flagEl.classList.add(flag);
	      flagEl.onclick = (e) => {
	        e.stopPropagation();
	        toggleFlag(lineNum);
	        showDiffList();
	      };

	      container.appendChild(flagEl);
	      container.appendChild(span);
	    });
	  }


	  function getFlagSymbol(state) {
		if (state === "green") return "âœ…";
		if (state === "red") return "ðŸš©";
		return "âš";
	  }

	  function toggleFlag(lineNum) {
		const lineId = getLineId(lineNum);
		const current = lineFlags[lineId];
		if (!current) lineFlags[lineId] = "green";
		else if (current === "green") lineFlags[lineId] = "red";
		else delete lineFlags[lineId];
	  }

	  function displayLine(lineNum) {
		currentLine = lineNum;
		currentLineDisplay.textContent = `Line: ${currentLine}`;
		currentLineDisplay.title = currentLine;
		
		const row = findRowByLineNumber(lineNum);
		if (!row) return;

		const lineId = getLineId(lineNum);

		const rText = (row["RIVERSIDE_TEXT"] || "").split(" ").filter(w => w.trim());
		const oText = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ");
		let oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		while (oTags.length < oText.length) oTags.push('');
		const rScansion = (row["RIVERSIDE_SCANSION"] || "").split(" ");
		let oScansion = oxfordScansionEdits[lineId] || (row["OXFORD_SCANSION"] || "").split(" ");
		while (oScansion.length < oText.length) oScansion.push('');

		// Get original text
		const rOriginal = row["OG_RIV_TEXT"] || "";
		const oOriginal = row["OG_OXFORD_TEXT"] || "";

		riversidePane.innerHTML = createLinePane(rText, rScansion, rTags, false, null, rOriginal);
		oxfordPane.innerHTML = createLinePane(oText, oScansion, oTags, true, lineId, oOriginal);

		flagBtn.className = "flag " + (lineFlags[lineId] || "");
		flagBtn.textContent = getFlagSymbol(lineFlags[lineId]);
	  }

	  function navigateLine(offset) {
		if (csvData.length === 0 || currentLine === null) return;
		let index = csvData.findIndex(r => getLineId(r["LINE_NUMBER"]) === getLineId(currentLine));
		if (index === -1) return;
		index = (index + offset + csvData.length) % csvData.length;
		displayLine(csvData[index]["LINE_NUMBER"]);
	  }

	  function navigateDiff(offset) {
	    if (!csvData.length || currentLine === null) return;

	    const diffLines = csvData
	      .filter(row => row["MATCH"] === "DIFF")
	      .map(row => row["LINE_NUMBER"])
	      .filter(lineNum => {
	        if (!hideGreenFlags.checked) return true;
	        return lineFlags[getLineId(lineNum)] !== "green";
	      });

	    if (!diffLines.length) return;

	    const currentIndex = diffLines.findIndex(
	      lineNum => getLineId(lineNum) === getLineId(currentLine)
	    );

	    if (currentIndex === -1) {
	      displayLine(diffLines[0]);
	      return;
	    }

	    const newIndex = currentIndex + offset;
	    if (newIndex >= 0 && newIndex < diffLines.length) {
	      displayLine(diffLines[newIndex]);
	    }
	  }


	  function createLinePane(words, scansion, tags, editable = false, lineId = null, originalText = "") {
		let html = "";
		
		if (toggleOriginal.checked && originalText && originalText.trim()) {
		  html += `<div class="original-text">
			<div class="original-label">Original:</div>
			${originalText}
		  </div>`;
		}
		
		const wordBlocks = words.map((word, i) => {
		  const editableClass = (editable && editMode) ? 'editable' : '';
		  const scanText = scansion[i] || '';
		  const scan = toggleScansion.checked 
			? `<span class="scansion ${editableClass}" data-type="scansion" data-index="${i}" data-line="${lineId}">${scanText}</span>` 
			: "";
		  
		  const tagText = tags[i] || '';
		  const displayTagText = tagText === '' ? '(no tag)' : tagText;
		  const tagClass = tagText === '' ? 'tag no-tag' : 'tag';
		  const tag = toggleTags.checked
			? `<span class="${tagClass}" data-word="${word}" data-index="${i}" data-line="${lineId}">${displayTagText}</span>`
			: "";
		  
		  const wordControls = (editable && editMode) 
			? `<span class="word-controls">
				<button class="word-control-btn add-before" onclick="addWordBefore('${lineId}', ${i})" title="Add word before">+</button>
				<button class="word-control-btn" onclick="removeWord('${lineId}', ${i})" title="Remove word">-</button>
			   </span>`
			: "";
		  
		  return `<div class="word-block">
			${wordControls}
			${scan}
			${tag}
			<span class="word ${editableClass}" data-type="word" data-index="${i}" data-line="${lineId}">${word}</span>
		  </div>`;
		}).join(" ");
		
		html += wordBlocks;
		
		if (editable && editMode) {
		  html += ` <button class="add-word-btn" onclick="addWordAtEnd('${lineId}')">+ Add Word at End</button>`;
		}
		
		return html;
	  }

	  // Word manipulation functions
	  function addWordBefore(lineId, index) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 0, newWord.trim());
		  oxfordTagEdits[lineId].splice(index, 0, '');
		  oxfordScansionEdits[lineId].splice(index, 0, '');
		  
		  displayLine(currentLine);
		}
	  }

	  function addWordAtEnd(lineId) {
		const newWord = prompt("Enter new word:");
		if (newWord && newWord.trim()) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].push(newWord.trim());
		  oxfordTagEdits[lineId].push('');
		  oxfordScansionEdits[lineId].push('');
		  
		  displayLine(currentLine);
		}
	  }

	  function removeWord(lineId, index) {
		if (confirm("Remove this word?")) {
		  initializeEditArrays(lineId);
		  
		  oxfordTextEdits[lineId].splice(index, 1);
		  oxfordTagEdits[lineId].splice(index, 1);
		  oxfordScansionEdits[lineId].splice(index, 1);
		  
		  displayLine(currentLine);
		}
	  }

	  function initializeEditArrays(lineId) {
		if (!oxfordTextEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTextEdits[lineId] = (row["OXFORD_TEXT"] || "").split(" ").filter(w => w.trim());
		}
		if (!oxfordTagEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordTagEdits[lineId] = (row["OXFORD_TAGGING"] || "").split(" ");
		}
		if (!oxfordScansionEdits[lineId]) {
		  const row = findRowByLineNumber(lineId);
		  oxfordScansionEdits[lineId] = (row["OXFORD_SCANSION"] || "").split(" ");
		}
	  }

	  // Make functions globally available
	  window.addWordBefore = addWordBefore;
	  window.addWordAtEnd = addWordAtEnd;
	  window.removeWord = removeWord;

	  // Click event handlers for inline editing
	  document.body.addEventListener('click', function (e) {
		const el = e.target;
		
		// Handle tag editing (existing functionality)
		if (el.classList.contains('tag') && el.dataset.line && !editMode) {
		  showTagEditor(el);
		} 
		// Handle inline text/scansion editing in edit mode
		else if ((el.classList.contains('editable')) && editMode && el.dataset.line) {
		  startInlineEdit(el);
		}
		// Handle tag editing in edit mode
		else if (el.classList.contains('tag') && el.dataset.line && editMode) {
		  showTagEditor(el);
		}
		else {
		  // Close any open editors
		  const existing = document.querySelector('.tag-editor');
		  if (existing) existing.remove();
		}
	  });

	  function startInlineEdit(element) {
		const currentText = element.textContent;
		const input = document.createElement('input');
		input.className = 'inline-edit';
		input.value = currentText;
		input.style.width = Math.max(50, currentText.length * 8) + 'px';
		
		element.parentNode.replaceChild(input, element);
		input.focus();
		input.select();

		function finishEdit() {
		  const newValue = input.value.trim();
		  element.textContent = newValue;
		  input.parentNode.replaceChild(element, input);
		  
		  // Update the data
		  const lineId = element.dataset.line;
		  const index = parseInt(element.dataset.index);
		  const type = element.dataset.type;
		  
		  initializeEditArrays(lineId);
		  
		  if (type === 'word') {
			oxfordTextEdits[lineId][index] = newValue;
		  } else if (type === 'scansion') {
			oxfordScansionEdits[lineId][index] = newValue;
		  }
		}

		input.addEventListener('blur', finishEdit);
		input.addEventListener('keydown', (e) => {
		  if (e.key === 'Enter') {
			finishEdit();
		  } else if (e.key === 'Escape') {
			element.textContent = currentText;
			input.parentNode.replaceChild(element, input);
		  }
		});
	  }

	  function showTagEditor(tagEl) {
		const word = tagEl.dataset.word.toLowerCase();
		const index = parseInt(tagEl.dataset.index);
		const lineId = tagEl.dataset.line;

		const rect = tagEl.getBoundingClientRect();
		const editor = document.createElement('div');
		editor.className = 'tag-editor';
		editor.style.top = `${rect.bottom + window.scrollY}px`;
		editor.style.left = `${rect.left + window.scrollX}px`;

		const suggestions = tagSuggestions[word] || {};
		const entries = Object.entries(suggestions);

		if (entries.length > 0) {
		  const sorted = entries.sort((a, b) => b[1] - a[1]);
		  sorted.forEach(([tag, freq]) => {
			const div = document.createElement('div');
			div.textContent = `${tag} (${freq})`;
			div.onclick = () => {
			  updateTag(lineId, index, tag);
			  editor.remove();
			};
			editor.appendChild(div);
		  });
		}

		// Add Riverside suggestions if enabled
		if (useRiversideSuggestions.checked) {
		  const row = findRowByLineNumber(lineId);
		  if (row) {
			const rTags = (row["RIVERSIDE_TAGGING"] || "").split(" ").filter(t => t.trim());
			const oTags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ").filter(t => t.trim());
			
			// Find all tags in Riverside
			const riversideTagsSet = new Set(rTags);
			
			// Remove tags that are already in Oxford
			oTags.forEach(tag => {
			  riversideTagsSet.delete(tag);
			});
			
			// Add a separator if there are both JSON suggestions and Riverside suggestions
			if (entries.length > 0 && riversideTagsSet.size > 0) {
			  const separator = document.createElement('div');
			  separator.style.borderTop = '1px solid #ccc';
			  separator.style.margin = '4px 0';
			  separator.style.padding = '2px 6px';
			  separator.style.fontWeight = 'bold';
			  separator.style.fontSize = '0.85em';
			  separator.style.color = '#666';
			  separator.textContent = 'From Riverside:';
			  separator.style.cursor = 'default';
			  editor.appendChild(separator);
			}
			
			// Add Riverside suggestions
			Array.from(riversideTagsSet).forEach(tag => {
			  const div = document.createElement('div');
			  div.textContent = `${tag} (from Riverside)`;
			  div.style.fontStyle = 'italic';
			  div.onclick = () => {
				updateTag(lineId, index, tag);
				editor.remove();
			  };
			  editor.appendChild(div);
			});
		  }
		}

		// Allow custom input
		const input = document.createElement('input');
		input.className = 'tag-input';
		input.placeholder = 'Custom tag...';
		input.onkeydown = (e) => {
		  if (e.key === 'Enter') {
			updateTag(lineId, index, input.value.trim());
			editor.remove();
		  }
		};
		editor.appendChild(input);

		document.body.appendChild(editor);
		input.focus();
	  }

	  function updateTag(lineId, index, tag) {
		const row = findRowByLineNumber(lineId);
		if (!row) return;
		
		let tags = oxfordTagEdits[lineId] || (row["OXFORD_TAGGING"] || "").split(" ");
		const textWords = oxfordTextEdits[lineId] || (row["OXFORD_TEXT"] || "").split(" ").filter(word => word && word.trim());
		while (tags.length < textWords.length) tags.push('');
		tags[index] = tag;
		oxfordTagEdits[lineId] = tags;
		displayLine(currentLine);
	  }
	</script>
  </body>
</html>
